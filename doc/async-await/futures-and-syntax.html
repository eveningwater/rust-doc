<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Future 与异步语法 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.b04b0b2c.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.efacb3ac.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.de3bffe6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.5cc4c8d6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/54.542efa92.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.eb17c9b1.js"><link rel="prefetch" href="/rust-doc/assets/js/100.9ca6c424.js"><link rel="prefetch" href="/rust-doc/assets/js/101.bb329080.js"><link rel="prefetch" href="/rust-doc/assets/js/102.daf1e517.js"><link rel="prefetch" href="/rust-doc/assets/js/103.0df6678e.js"><link rel="prefetch" href="/rust-doc/assets/js/104.f682d28e.js"><link rel="prefetch" href="/rust-doc/assets/js/105.2d9d469f.js"><link rel="prefetch" href="/rust-doc/assets/js/106.24f17fbf.js"><link rel="prefetch" href="/rust-doc/assets/js/107.716982fb.js"><link rel="prefetch" href="/rust-doc/assets/js/108.7d757dac.js"><link rel="prefetch" href="/rust-doc/assets/js/109.6156d2ad.js"><link rel="prefetch" href="/rust-doc/assets/js/11.4d96857f.js"><link rel="prefetch" href="/rust-doc/assets/js/110.59e0a394.js"><link rel="prefetch" href="/rust-doc/assets/js/111.45810bbb.js"><link rel="prefetch" href="/rust-doc/assets/js/112.a94879e7.js"><link rel="prefetch" href="/rust-doc/assets/js/113.d01b1967.js"><link rel="prefetch" href="/rust-doc/assets/js/114.27b51e42.js"><link rel="prefetch" href="/rust-doc/assets/js/115.a60af695.js"><link rel="prefetch" href="/rust-doc/assets/js/116.a4be2b68.js"><link rel="prefetch" href="/rust-doc/assets/js/117.69975126.js"><link rel="prefetch" href="/rust-doc/assets/js/118.173a6d8a.js"><link rel="prefetch" href="/rust-doc/assets/js/119.1d2a40e2.js"><link rel="prefetch" href="/rust-doc/assets/js/12.0eea138a.js"><link rel="prefetch" href="/rust-doc/assets/js/120.b76f01db.js"><link rel="prefetch" href="/rust-doc/assets/js/121.5f6fca17.js"><link rel="prefetch" href="/rust-doc/assets/js/122.00c1547a.js"><link rel="prefetch" href="/rust-doc/assets/js/123.34457b55.js"><link rel="prefetch" href="/rust-doc/assets/js/124.75c4d9e1.js"><link rel="prefetch" href="/rust-doc/assets/js/13.da6262af.js"><link rel="prefetch" href="/rust-doc/assets/js/14.1378ae14.js"><link rel="prefetch" href="/rust-doc/assets/js/15.c72c8a9e.js"><link rel="prefetch" href="/rust-doc/assets/js/16.1c185a04.js"><link rel="prefetch" href="/rust-doc/assets/js/17.de44e6d9.js"><link rel="prefetch" href="/rust-doc/assets/js/18.d72bda36.js"><link rel="prefetch" href="/rust-doc/assets/js/19.ac65ddaa.js"><link rel="prefetch" href="/rust-doc/assets/js/20.b2f37783.js"><link rel="prefetch" href="/rust-doc/assets/js/21.bc7abb0d.js"><link rel="prefetch" href="/rust-doc/assets/js/22.aead3977.js"><link rel="prefetch" href="/rust-doc/assets/js/23.1d08a258.js"><link rel="prefetch" href="/rust-doc/assets/js/24.3123e7b2.js"><link rel="prefetch" href="/rust-doc/assets/js/25.c92ccfb3.js"><link rel="prefetch" href="/rust-doc/assets/js/26.7cf20f6f.js"><link rel="prefetch" href="/rust-doc/assets/js/27.b6484f43.js"><link rel="prefetch" href="/rust-doc/assets/js/28.f2117f45.js"><link rel="prefetch" href="/rust-doc/assets/js/29.7b185968.js"><link rel="prefetch" href="/rust-doc/assets/js/3.bfcba754.js"><link rel="prefetch" href="/rust-doc/assets/js/30.2cf64d35.js"><link rel="prefetch" href="/rust-doc/assets/js/31.85ee7a33.js"><link rel="prefetch" href="/rust-doc/assets/js/32.074f8603.js"><link rel="prefetch" href="/rust-doc/assets/js/33.921a026f.js"><link rel="prefetch" href="/rust-doc/assets/js/34.629b0402.js"><link rel="prefetch" href="/rust-doc/assets/js/35.251e1b14.js"><link rel="prefetch" href="/rust-doc/assets/js/36.20741c45.js"><link rel="prefetch" href="/rust-doc/assets/js/37.5e2a0666.js"><link rel="prefetch" href="/rust-doc/assets/js/38.4cf24d2e.js"><link rel="prefetch" href="/rust-doc/assets/js/39.7fdae498.js"><link rel="prefetch" href="/rust-doc/assets/js/4.508a9818.js"><link rel="prefetch" href="/rust-doc/assets/js/40.1e3fb94a.js"><link rel="prefetch" href="/rust-doc/assets/js/41.bcd39ff7.js"><link rel="prefetch" href="/rust-doc/assets/js/42.8ed1746b.js"><link rel="prefetch" href="/rust-doc/assets/js/43.7b5d5051.js"><link rel="prefetch" href="/rust-doc/assets/js/44.d3c7c2f4.js"><link rel="prefetch" href="/rust-doc/assets/js/45.18f08bf2.js"><link rel="prefetch" href="/rust-doc/assets/js/46.991c99d4.js"><link rel="prefetch" href="/rust-doc/assets/js/47.c83cae97.js"><link rel="prefetch" href="/rust-doc/assets/js/48.ab0dce9d.js"><link rel="prefetch" href="/rust-doc/assets/js/49.03478c58.js"><link rel="prefetch" href="/rust-doc/assets/js/5.f95f0a29.js"><link rel="prefetch" href="/rust-doc/assets/js/50.90bb420d.js"><link rel="prefetch" href="/rust-doc/assets/js/51.8b4399f7.js"><link rel="prefetch" href="/rust-doc/assets/js/52.4a84ada8.js"><link rel="prefetch" href="/rust-doc/assets/js/53.da46253f.js"><link rel="prefetch" href="/rust-doc/assets/js/55.2fca383d.js"><link rel="prefetch" href="/rust-doc/assets/js/56.c42f8621.js"><link rel="prefetch" href="/rust-doc/assets/js/57.12aec400.js"><link rel="prefetch" href="/rust-doc/assets/js/58.d968498a.js"><link rel="prefetch" href="/rust-doc/assets/js/59.b56f3afb.js"><link rel="prefetch" href="/rust-doc/assets/js/6.c4bf9bde.js"><link rel="prefetch" href="/rust-doc/assets/js/60.fd1c19c0.js"><link rel="prefetch" href="/rust-doc/assets/js/61.cc7b5424.js"><link rel="prefetch" href="/rust-doc/assets/js/62.2a76c9a7.js"><link rel="prefetch" href="/rust-doc/assets/js/63.708fc434.js"><link rel="prefetch" href="/rust-doc/assets/js/64.cddf5346.js"><link rel="prefetch" href="/rust-doc/assets/js/65.9dae14fb.js"><link rel="prefetch" href="/rust-doc/assets/js/66.95fec542.js"><link rel="prefetch" href="/rust-doc/assets/js/67.c6efee59.js"><link rel="prefetch" href="/rust-doc/assets/js/68.93c56b9c.js"><link rel="prefetch" href="/rust-doc/assets/js/69.bc0e5731.js"><link rel="prefetch" href="/rust-doc/assets/js/7.7610c249.js"><link rel="prefetch" href="/rust-doc/assets/js/70.6a74fb5f.js"><link rel="prefetch" href="/rust-doc/assets/js/71.ed15c34a.js"><link rel="prefetch" href="/rust-doc/assets/js/72.2395c15a.js"><link rel="prefetch" href="/rust-doc/assets/js/73.12dbe8eb.js"><link rel="prefetch" href="/rust-doc/assets/js/74.ffa53005.js"><link rel="prefetch" href="/rust-doc/assets/js/75.8098652c.js"><link rel="prefetch" href="/rust-doc/assets/js/76.978a6896.js"><link rel="prefetch" href="/rust-doc/assets/js/77.7569e538.js"><link rel="prefetch" href="/rust-doc/assets/js/78.18a8b1a7.js"><link rel="prefetch" href="/rust-doc/assets/js/79.c22eefe2.js"><link rel="prefetch" href="/rust-doc/assets/js/80.23b488e7.js"><link rel="prefetch" href="/rust-doc/assets/js/81.8b0bde45.js"><link rel="prefetch" href="/rust-doc/assets/js/82.d0c33cf2.js"><link rel="prefetch" href="/rust-doc/assets/js/83.8f9f1372.js"><link rel="prefetch" href="/rust-doc/assets/js/84.dadc4aa3.js"><link rel="prefetch" href="/rust-doc/assets/js/85.9edd56e8.js"><link rel="prefetch" href="/rust-doc/assets/js/86.a8dd0039.js"><link rel="prefetch" href="/rust-doc/assets/js/87.f49d182c.js"><link rel="prefetch" href="/rust-doc/assets/js/88.54a1660f.js"><link rel="prefetch" href="/rust-doc/assets/js/89.70cc8ec5.js"><link rel="prefetch" href="/rust-doc/assets/js/90.3e99f899.js"><link rel="prefetch" href="/rust-doc/assets/js/91.92c957ea.js"><link rel="prefetch" href="/rust-doc/assets/js/92.7d33aa1c.js"><link rel="prefetch" href="/rust-doc/assets/js/93.7720ff15.js"><link rel="prefetch" href="/rust-doc/assets/js/94.510fab09.js"><link rel="prefetch" href="/rust-doc/assets/js/95.d8659c14.js"><link rel="prefetch" href="/rust-doc/assets/js/96.942fde83.js"><link rel="prefetch" href="/rust-doc/assets/js/97.6b253f7c.js"><link rel="prefetch" href="/rust-doc/assets/js/98.94d2767a.js"><link rel="prefetch" href="/rust-doc/assets/js/99.40299eec.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.3b28fe31.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.b04b0b2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable"><span>认识所有权</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/packages-crates-and-modules/packages-crates-and-modules" class="sidebar-heading clickable"><span>使用包、依赖箱和模块管理不断增长的项目</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-collections/common-collections" class="sidebar-heading clickable"><span>常用集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/error-handling/error-handling" class="sidebar-heading clickable"><span>错误处理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/generics/generics" class="sidebar-heading clickable"><span>泛型类型、特性和生命周期</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/testing/testing" class="sidebar-heading clickable"><span>测试</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/an-io-project/an-io-project" class="sidebar-heading clickable"><span>I/O 项目：构建命令行程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/functional-features/functional-features" class="sidebar-heading clickable"><span>函数式语言特性：迭代器与闭包</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/more-about-cargo/more-about-cargo" class="sidebar-heading clickable"><span>关于 Cargo 和 Crates.io 的更多信息</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/smart-pointers/smart-pointers" class="sidebar-heading clickable"><span>智能指针</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/concurrency/concurrency" class="sidebar-heading clickable"><span>无畏并发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/async-await/async-await" class="sidebar-heading clickable open"><span>异步编程基础：Async、Await、Futures 和 Streams</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/async-await/futures-and-syntax.html" aria-current="page" class="active sidebar-link">Future 与异步语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/async-await/futures-and-syntax.html#future-与异步语法" class="sidebar-link">Future 与异步语法</a></li></ul></li><li><a href="/rust-doc/doc/async-await/concurrency-with-async.html" class="sidebar-link">应用异步并发</a></li><li><a href="/rust-doc/doc/async-await/more-futures.html" class="sidebar-link">处理任意数量的 Future</a></li><li><a href="/rust-doc/doc/async-await/streams.html" class="sidebar-link">流：按顺序排列的 Future</a></li><li><a href="/rust-doc/doc/async-await/traits-for-async.html" class="sidebar-link">深入了解异步特性</a></li><li><a href="/rust-doc/doc/async-await/futures-tasks-threads.html" class="sidebar-link">整合：Future、任务和线程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/oop/oop" class="sidebar-heading clickable"><span>面向对象编程特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/patterns/patterns" class="sidebar-heading clickable"><span>模式与匹配</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/advanced-features/advanced-features" class="sidebar-heading clickable"><span>高级特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="future-与异步语法"><a href="#future-与异步语法" class="header-anchor">#</a> Future 与异步语法</h2> <p>Rust 中异步编程的关键要素是 future 以及 Rust 的 <code>async</code> 和 <code>await</code> 关键字。</p> <p>Future 是一个可能现在还未就绪，但将来某个时候会就绪的值。（这个概念在许多语言中都有出现，有时也称为任务或 Promise。）Rust 提供了一个 <code>Future</code> trait 作为构建块，以便不同的异步操作可以使用不同的数据结构实现，但具有一个共同的接口。在 Rust 中，future 是实现 <code>Future</code> trait 的类型。每个 future 都包含其自身关于已取得的进展以及“就绪”意味着什么的信息。</p> <p>你可以将 <code>async</code> 关键字应用于块和函数，以指定它们可以被中断和恢复。在 <code>async</code> 块或 <code>async</code> 函数中，你可以使用 <code>await</code> 关键字来等待一个 future（即，等待它变为就绪）。在 <code>async</code> 块或函数中等待 future 的任何点都是该 <code>async</code> 块或函数暂停和恢复的潜在位置。与 future 检查其值是否可用的过程称为轮询（polling）。</p> <p>其他一些语言，例如 C# 和 JavaScript，也使用 <code>async</code> 和 <code>await</code> 关键字进行异步编程。如果你熟悉这些语言，你可能会注意到 Rust 的处理方式有一些显著差异，包括它如何处理语法。这是有充分理由的，我们将会看到！</p> <p>在编写异步 Rust 时，我们大部分时间都使用 <code>async</code> 和 <code>await</code> 关键字。Rust 将它们编译成使用 <code>Future</code> trait 的等效代码，就像它将 <code>for</code> 循环编译成使用 <code>Iterator</code> trait 的等效代码一样。然而，由于 Rust 提供了 <code>Future</code> trait，你也可以在需要时为自己的数据类型实现它。我们将在本章中看到的许多函数都返回带有自己 <code>Future</code> 实现的类型。我们将在本章末尾回到 trait 的定义，并深入探讨它的工作原理，但这些细节足以让我们继续前进。</p> <p>这可能感觉有点抽象，所以让我们编写我们的第一个异步程序：一个小型网络爬虫。我们将从命令行传入两个 URL，并发地获取它们，并返回其中任何一个先完成的结果。这个例子将包含一些新的语法，但不用担心——我们将在过程中解释你需要知道的一切。</p> <h3 id="我们的第一个异步程序"><a href="#我们的第一个异步程序" class="header-anchor">#</a> 我们的第一个异步程序</h3> <p>为了将本章的重点放在学习异步而不是处理生态系统上，我们创建了 <code>trpl</code> crate（<code>trpl</code> 是“The Rust Programming Language”的缩写）。它重新导出了你将需要的所有类型、trait 和函数，主要来自 <code>futures</code> 和 <code>tokio</code> crate。<code>futures</code> crate 是 Rust 异步代码实验的官方场所，它实际上是 <code>Future</code> trait 最初设计的地方。<code>tokio</code> 是当今 Rust 中使用最广泛的异步运行时，特别是对于 Web 应用程序。还有其他优秀的运行时，它们可能更适合你的目的。我们在 <code>trpl</code> 内部使用 <code>tokio</code> crate，因为它经过了充分测试并被广泛使用。</p> <p>在某些情况下，<code>trpl</code> 还会重命名或包装原始 API，以让你专注于与本章相关的细节。如果你想了解这个 crate 的作用，我们鼓励你查看其源代码。你将能够看到每个重新导出来自哪个 crate，并且我们留下了大量的注释来解释这个 crate 的作用。</p> <p>创建一个名为 <code>hello-async</code> 的新二进制项目，并将 <code>trpl</code> crate 添加为依赖项：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo new hello<span class="token operator">-</span><span class="token keyword">async</span>
$ cd hello<span class="token operator">-</span><span class="token keyword">async</span>
$ cargo add trpl
</code></pre></div><p>现在我们可以使用 <code>trpl</code> 提供的各种组件来编写我们的第一个异步程序。我们将构建一个小型命令行工具，它获取两个网页，从每个网页中提取 <code>&lt;title&gt;</code> 元素，并打印出哪个页面先完成整个过程的标题。</p> <h3 id="定义-page-title-函数"><a href="#定义-page-title-函数" class="header-anchor">#</a> 定义 <code>page_title</code> 函数</h3> <p>让我们从编写一个函数开始，该函数接受一个页面 URL 作为参数，向其发出请求，并返回标题元素的文本（参见 Listing 17-1）。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: we'll add this next!</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Html</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> response_text <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response_text<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title_element<span class="token closure-punctuation punctuation">|</span></span> title_element<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Listing 17-1: 定义一个异步函数以从 HTML 页面获取标题元素</p> <p>首先，我们定义一个名为 <code>page_title</code> 的函数，并用 <code>async</code> 关键字标记它。然后我们使用 <code>trpl::get</code> 函数获取传入的任何 URL，并添加 <code>await</code> 关键字来等待响应。为了获取响应的文本，我们调用其 <code>text</code> 方法，并再次使用 <code>await</code> 关键字等待它。这两个步骤都是异步的。对于 <code>get</code> 函数，我们必须等待服务器发回响应的第一部分，其中将包含 HTTP 头、cookie 等，并且可以与响应正文分开传递。特别是如果正文非常大，它可能需要一些时间才能全部到达。因为我们必须等待整个响应到达，所以 <code>text</code> 方法也是异步的。</p> <p>我们必须显式地等待这两个 future，因为 Rust 中的 future 是惰性的：除非你使用 <code>await</code> 关键字要求它们，否则它们不会做任何事情。（事实上，如果你不使用 future，Rust 会显示一个编译器警告。）这可能会让你想起第 13 章中关于迭代器在“使用迭代器处理一系列项”一节中的讨论。迭代器除非你调用它们的 <code>next</code> 方法——无论是直接调用还是通过使用 <code>for</code> 循环或在底层使用 <code>next</code> 的方法（如 <code>map</code>）——否则它们不会做任何事情。同样，future 除非你显式地要求它们，否则它们不会做任何事情。这种惰性允许 Rust 避免运行异步代码，直到它真正需要时才运行。</p> <blockquote><p>注意：这与我们在上一章中使用 <code>thread::spawn</code> 在“使用 <code>spawn</code> 创建新线程”中看到的行为不同，在那里我们传递给另一个线程的闭包会立即开始运行。这与许多其他语言处理异步的方式也不同。但对于 Rust 来说，能够提供其性能保证非常重要，就像迭代器一样。</p></blockquote> <p>一旦我们有了 <code>response_text</code>，我们就可以使用 <code>Html::parse</code> 将其解析为 <code>Html</code> 类型的一个实例。现在我们不再是原始字符串，而是一种可以用来处理 HTML 作为更丰富数据类型的类型。特别是，我们可以使用 <code>select_first</code> 方法来查找给定 CSS 选择器的第一个实例。通过传入字符串 <code>&quot;title&quot;</code>，我们将获取文档中的第一个 <code>&lt;title&gt;</code> 元素（如果存在）。因为可能没有任何匹配的元素，<code>select_first</code> 返回一个 <code>Option&lt;ElementRef&gt;</code>。最后，我们使用 <code>Option::map</code> 方法，它允许我们处理 <code>Option</code> 中的项（如果存在），如果不存在则不执行任何操作。（我们也可以在这里使用 <code>match</code> 表达式，但 <code>map</code> 更符合习惯。）在提供给 <code>map</code> 的函数体中，我们对 <code>title_element</code> 调用 <code>inner_html</code> 以获取其内容，这是一个 <code>String</code>。最终，我们得到了一个 <code>Option&lt;String&gt;</code>。</p> <p>请注意，Rust 的 <code>await</code> 关键字位于你正在等待的表达式之后，而不是之前。也就是说，它是一个后缀关键字。这可能与你使用其他语言中的异步时所习惯的不同，但在 Rust 中，它使得方法链更容易使用。因此，我们可以更改 <code>page_title</code> 的主体，将 <code>trpl::get</code> 和 <code>text</code> 函数调用与 <code>await</code> 链接在一起，如 Listing 17-2 所示。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Html</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: we'll add this next!</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response_text <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response_text<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title_element<span class="token closure-punctuation punctuation">|</span></span> title_element<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Listing 17-2: 使用 <code>await</code> 关键字进行链式调用</p> <p>至此，我们已经成功编写了第一个异步函数！在我们添加一些代码到 <code>main</code> 中来调用它之前，让我们再多谈谈我们所写的内容以及它的含义。</p> <p>当 Rust 看到用 <code>async</code> 关键字标记的块时，它会将其编译成一个唯一的匿名数据类型，该类型实现了 <code>Future</code> trait。当 Rust 看到用 <code>async</code> 标记的函数时，它会将其编译成一个非异步函数，其主体是一个 <code>async</code> 块。异步函数的返回类型是编译器为该 <code>async</code> 块创建的匿名数据类型的类型。</p> <p>因此，编写 <code>async fn</code> 等同于编写一个返回返回类型 future 的函数。对于编译器来说，像 Listing 17-1 中的 <code>async fn page_title</code> 这样的函数定义等同于这样定义的非异步函数：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>
<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>future<span class="token punctuation">::</span></span><span class="token class-name">Future</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Html</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">async</span> <span class="token keyword">move</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
        <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>text<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title<span class="token closure-punctuation punctuation">|</span></span> title<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们逐一分析转换后的版本：</p> <ul><li>它使用了我们在第 10 章“Trait 作为参数”一节中讨论的 <code>impl Trait</code> 语法。</li> <li>返回的 trait 是一个 <code>Future</code>，带有一个关联类型 <code>Output</code>。请注意，<code>Output</code> 类型是 <code>Option&lt;String&gt;</code>，这与 <code>async fn</code> 版本的 <code>page_title</code> 的原始返回类型相同。</li> <li>原始函数体中调用的所有代码都包装在一个 <code>async move</code> 块中。请记住，块是表达式。整个块是函数返回的表达式。</li> <li>这个 <code>async</code> 块生成一个类型为 <code>Option&lt;String&gt;</code> 的值，如前所述。该值与返回类型中的 <code>Output</code> 类型匹配。这就像你见过的其他块一样。</li> <li>新的函数体是一个 <code>async move</code> 块，因为它使用了 <code>url</code> 参数。（我们将在本章后面更详细地讨论 <code>async</code> 与 <code>async move</code>。）</li></ul> <p>现在我们可以在 <code>main</code> 中调用 <code>page_title</code>。</p> <h3 id="确定单个页面的标题"><a href="#确定单个页面的标题" class="header-anchor">#</a> 确定单个页面的标题</h3> <p>首先，我们只获取单个页面的标题。在 Listing 17-3 中，我们遵循了第 12 章中在“接受命令行参数”一节中获取命令行参数的相同模式。然后我们将第一个 URL <code>page_title</code> 传递给它并等待结果。因为 future 生成的值是 <code>Option&lt;String&gt;</code>，所以我们使用 <code>match</code> 表达式打印不同的消息，以说明页面是否包含 <code>&lt;title&gt;</code>。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Html</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> <span class="token function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The title for {url} was {title}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{url} had no title&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response_text <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response_text<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title_element<span class="token closure-punctuation punctuation">|</span></span> title_element<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Listing 17-3: 从 <code>main</code> 中调用 <code>page_title</code> 函数，带有一个用户提供的参数</p> <p>不幸的是，这段代码无法编译。我们只能在异步函数或块中使用 <code>await</code> 关键字，Rust 不允许我们将特殊的 <code>main</code> 函数标记为异步。</p> <div class="language-rust extra-class"><pre class="language-rust"><code>error<span class="token punctuation">[</span><span class="token constant">E0752</span><span class="token punctuation">]</span><span class="token punctuation">:</span> `main` function is not allowed to be `<span class="token keyword">async</span>`
 <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">1</span>
  <span class="token operator">|</span>
<span class="token number">6</span> <span class="token operator">|</span> <span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">|</span> <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> `main` function is not allowed to be `<span class="token keyword">async</span>`
</code></pre></div><p><code>main</code> 不能被标记为 <code>async</code> 的原因是异步代码需要一个运行时：一个管理异步代码执行细节的 Rust crate。程序的 <code>main</code> 函数可以初始化一个运行时，但它本身不是一个运行时。（我们稍后会看到为什么会这样。）每个执行异步代码的 Rust 程序至少有一个地方设置运行时并执行 future。</p> <p>大多数支持异步的语言都捆绑了一个运行时，但 Rust 没有。相反，有许多不同的异步运行时可用，每个运行时都根据其目标用例做出不同的权衡。例如，一个拥有许多 CPU 核心和大量 RAM 的高吞吐量 Web 服务器与一个只有单个核心、少量 RAM 且没有堆分配能力的微控制器有非常不同的需求。提供这些运行时的 crate 通常也提供常见功能的异步版本，例如文件或网络 I/O。</p> <p>在这里，以及在本章的其余部分，我们将使用 <code>trpl</code> crate 中的 <code>run</code> 函数，它接受一个 future 作为参数并将其运行到完成。在幕后，调用 <code>run</code> 会设置一个运行时，用于运行传入的 future。一旦 future 完成，<code>run</code> 会返回 future 生成的任何值。</p> <p>我们可以将 <code>page_title</code> 返回的 future 直接传递给 <code>run</code>，一旦它完成，我们就可以匹配结果 <code>Option&lt;String&gt;</code>，就像我们在 Listing 17-3 中尝试的那样。然而，对于本章中的大多数示例（以及现实世界中的大多数异步代码），我们将不仅仅进行一次异步函数调用，因此我们将传递一个 <code>async</code> 块并显式等待 <code>page_title</code> 调用的结果，如 Listing 17-4 所示。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Html</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">match</span> <span class="token function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
            <span class="token class-name">Some</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The title for {url} was {title}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{url} had no title&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response_text <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response_text<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title_element<span class="token closure-punctuation punctuation">|</span></span> title_element<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Listing 17-4: 使用 <code>trpl::run</code> 等待一个异步块</p> <p>当我们运行这段代码时，我们得到了最初预期的行为：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo run <span class="token operator">-</span><span class="token operator">-</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>rust<span class="token operator">-</span>lang<span class="token punctuation">.</span>org
    <span class="token class-name">Finished</span> `dev` profile <span class="token punctuation">[</span>unoptimized <span class="token operator">+</span> debuginfo<span class="token punctuation">]</span> <span class="token function">target</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span>05s
     <span class="token class-name">Running</span> `target<span class="token operator">/</span>debug<span class="token operator">/</span>async_await <span class="token lifetime-annotation symbol">'https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>rust<span class="token operator">-</span>lang<span class="token punctuation">.</span>org'`
<span class="token class-name">The</span> title <span class="token keyword">for</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>rust<span class="token operator">-</span>lang<span class="token punctuation">.</span>org was
            <span class="token class-name">Rust</span> <span class="token class-name">Programming</span> <span class="token class-name">Language</span>
</code></pre></div><p>呼——我们终于有了一些可用的异步代码！但在我们添加代码来让两个站点相互竞争之前，让我们简要地将注意力转回到 future 的工作原理。</p> <p>每个 <code>await</code> 点——也就是说，代码中使用 <code>await</code> 关键字的每个地方——都表示控制权交还给运行时的地方。为了实现这一点，Rust 需要跟踪 <code>async</code> 块中涉及的状态，以便运行时可以启动其他工作，然后在准备好再次尝试推进第一个工作时返回。这是一个不可见的状态机，就好像你编写了一个这样的枚举来保存每个 <code>await</code> 点的当前状态：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">enum</span> <span class="token type-definition class-name">PageTitleFuture</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Initial</span> <span class="token punctuation">{</span> url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">GetAwaitPoint</span> <span class="token punctuation">{</span> url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">TextAwaitPoint</span> <span class="token punctuation">{</span> response<span class="token punctuation">:</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token class-name">Response</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，手动编写在每个状态之间转换的代码将是繁琐且容易出错的，特别是当你以后需要为代码添加更多功能和更多状态时。幸运的是，Rust 编译器会自动为异步代码创建和管理状态机数据结构。围绕数据结构的正常借用和所有权规则仍然适用，令人高兴的是，编译器也会为我们检查这些规则并提供有用的错误消息。我们将在本章后面讨论其中的一些。</p> <p>最终，必须有东西来执行这个状态机，而这个东西就是运行时。（这就是为什么你在研究运行时时可能会遇到执行器（executor）的引用：执行器是运行时中负责执行异步代码的部分。）</p> <p>现在你可以明白为什么编译器在 Listing 17-3 中阻止我们将 <code>main</code> 本身设为异步函数了。如果 <code>main</code> 是一个异步函数，那么就需要有其他东西来管理 <code>main</code> 返回的任何 future 的状态机，但 <code>main</code> 是程序的起点！相反，我们在 <code>main</code> 中调用了 <code>trpl::run</code> 函数来设置一个运行时，并运行 <code>async</code> 块返回的 future 直到它完成。</p> <blockquote><p>注意：一些运行时提供了宏，因此你可以编写一个异步 <code>main</code> 函数。这些宏将 <code>async fn main() { ... }</code> 重写为普通的 <code>fn main</code>，这与我们在 Listing 17-4 中手动完成的事情相同：调用一个函数，该函数以 <code>trpl::run</code> 的方式将 future 运行到完成。</p></blockquote> <p>现在让我们将这些部分组合起来，看看如何编写并发代码。</p> <h3 id="我们的两个-url-相互竞争"><a href="#我们的两个-url-相互竞争" class="header-anchor">#</a> 我们的两个 URL 相互竞争</h3> <p>在 Listing 17-5 中，我们使用从命令行传入的两个不同 URL 调用 <code>page_title</code> 并让它们竞争。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Either</span><span class="token punctuation">,</span> <span class="token class-name">Html</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> title_fut_1 <span class="token operator">=</span> <span class="token function">page_title</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> title_fut_2 <span class="token operator">=</span> <span class="token function">page_title</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> maybe_title<span class="token punctuation">)</span> <span class="token operator">=</span>
            <span class="token keyword">match</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">race</span><span class="token punctuation">(</span>title_fut_1<span class="token punctuation">,</span> title_fut_2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
                <span class="token class-name">Either</span><span class="token punctuation">::</span><span class="token class-name">Left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> left<span class="token punctuation">,</span>
                <span class="token class-name">Either</span><span class="token punctuation">::</span><span class="token class-name">Right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> right<span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{url} returned first&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">match</span> maybe_title <span class="token punctuation">{</span>
            <span class="token class-name">Some</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Its page title is: '{title}'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Its title could not be parsed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">page_title</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> title <span class="token operator">=</span> <span class="token class-name">Html</span><span class="token punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>text<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">select_first</span><span class="token punctuation">(</span><span class="token string">&quot;title&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>title<span class="token closure-punctuation punctuation">|</span></span> title<span class="token punctuation">.</span><span class="token function">inner_html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>url<span class="token punctuation">,</span> title<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Listing 17-5:</p> <p>我们首先为每个用户提供的 URL 调用 <code>page_title</code>。我们将结果 future 保存为 <code>title_fut_1</code> 和 <code>title_fut_2</code>。请记住，这些现在还没有做任何事情，因为 future 是惰性的，我们还没有等待它们。然后我们将这些 future 传递给 <code>trpl::race</code>，它返回一个值，指示哪个传入的 future 先完成。</p> <blockquote><p>注意：在底层，<code>race</code> 是建立在一个更通用的函数 <code>select</code> 之上的，你将在实际的 Rust 代码中更常见地遇到它。<code>select</code> 函数可以做很多 <code>trpl::race</code> 函数不能做的事情，但它也有一些额外的复杂性，我们现在可以跳过。</p></blockquote> <p>任何一个 future 都可以合法地“赢”，因此返回 <code>Result</code> 没有意义。相反，<code>race</code> 返回一个我们以前没有见过的类型，<code>trpl::Either</code>。<code>Either</code> 类型有点类似于 <code>Result</code>，因为它有两种情况。然而，与 <code>Result</code> 不同，<code>Either</code> 中没有内置成功或失败的概念。相反，它使用 <code>Left</code> 和 <code>Right</code> 来表示“二者之一”：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">enum</span> <span class="token type-definition class-name">Either</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Left</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Right</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>race</code> 函数在第一个 future 参数先完成时返回 <code>Left</code> 及其输出，或者在第二个 future 参数先完成时返回 <code>Right</code> 及其输出。这与调用函数时参数出现的顺序相匹配：第一个参数在第二个参数的左侧。</p> <p>我们还更新了 <code>page_title</code> 以返回传入的相同 URL。这样，如果先返回的页面没有我们可以解析的 <code>&lt;title&gt;</code>，我们仍然可以打印有意义的消息。有了这些信息，我们通过更新 <code>println!</code> 输出，指示哪个 URL 先完成以及该网页的 <code>&lt;title&gt;</code> 是什么（如果有的话）。</p> <p>你现在已经构建了一个小型可用的网络爬虫！选择几个 URL 并运行命令行工具。你可能会发现有些网站始终比其他网站快，而在其他情况下，更快的网站会因运行而异。更重要的是，你已经学会了使用 Future 的基础知识，所以现在我们可以更深入地研究异步编程能做什么。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/concurrency/extensible-concurrency-sync-and-send.html" class="prev">
        使用`Send`和`Sync`特性的可扩展并发
      </a></span> <span class="next"><a href="/rust-doc/doc/async-await/concurrency-with-async.html">
        应用异步并发
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.efacb3ac.js" defer></script><script src="/rust-doc/assets/js/2.de3bffe6.js" defer></script><script src="/rust-doc/assets/js/1.5cc4c8d6.js" defer></script><script src="/rust-doc/assets/js/54.542efa92.js" defer></script>
  </body>
</html>
