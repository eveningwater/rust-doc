<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>应用异步并发 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.b04b0b2c.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.a072e027.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.de3bffe6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.5cc4c8d6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/55.b62f2ebe.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.eb17c9b1.js"><link rel="prefetch" href="/rust-doc/assets/js/100.b000e386.js"><link rel="prefetch" href="/rust-doc/assets/js/101.7b0c5a1e.js"><link rel="prefetch" href="/rust-doc/assets/js/102.b3d3cf9f.js"><link rel="prefetch" href="/rust-doc/assets/js/103.83cf828b.js"><link rel="prefetch" href="/rust-doc/assets/js/104.a8b481d6.js"><link rel="prefetch" href="/rust-doc/assets/js/105.5300bfe3.js"><link rel="prefetch" href="/rust-doc/assets/js/106.794ab1ca.js"><link rel="prefetch" href="/rust-doc/assets/js/107.767d465d.js"><link rel="prefetch" href="/rust-doc/assets/js/108.306485b9.js"><link rel="prefetch" href="/rust-doc/assets/js/109.67aef446.js"><link rel="prefetch" href="/rust-doc/assets/js/11.4d96857f.js"><link rel="prefetch" href="/rust-doc/assets/js/110.415d8db1.js"><link rel="prefetch" href="/rust-doc/assets/js/111.b3ad9b53.js"><link rel="prefetch" href="/rust-doc/assets/js/112.3fa4fdb9.js"><link rel="prefetch" href="/rust-doc/assets/js/113.eca395d6.js"><link rel="prefetch" href="/rust-doc/assets/js/114.de689a0b.js"><link rel="prefetch" href="/rust-doc/assets/js/115.f47c0d84.js"><link rel="prefetch" href="/rust-doc/assets/js/116.299e88c6.js"><link rel="prefetch" href="/rust-doc/assets/js/117.a1b759ae.js"><link rel="prefetch" href="/rust-doc/assets/js/118.eb7cddd3.js"><link rel="prefetch" href="/rust-doc/assets/js/119.4a168af1.js"><link rel="prefetch" href="/rust-doc/assets/js/12.0eea138a.js"><link rel="prefetch" href="/rust-doc/assets/js/120.03f18f27.js"><link rel="prefetch" href="/rust-doc/assets/js/121.a1140ae7.js"><link rel="prefetch" href="/rust-doc/assets/js/122.1dec2ba7.js"><link rel="prefetch" href="/rust-doc/assets/js/123.44798165.js"><link rel="prefetch" href="/rust-doc/assets/js/124.f5b6b9fd.js"><link rel="prefetch" href="/rust-doc/assets/js/125.7080f568.js"><link rel="prefetch" href="/rust-doc/assets/js/126.e8e772ce.js"><link rel="prefetch" href="/rust-doc/assets/js/13.da6262af.js"><link rel="prefetch" href="/rust-doc/assets/js/14.9386ae96.js"><link rel="prefetch" href="/rust-doc/assets/js/15.c72c8a9e.js"><link rel="prefetch" href="/rust-doc/assets/js/16.1c185a04.js"><link rel="prefetch" href="/rust-doc/assets/js/17.5e3f0cae.js"><link rel="prefetch" href="/rust-doc/assets/js/18.38ede518.js"><link rel="prefetch" href="/rust-doc/assets/js/19.ac65ddaa.js"><link rel="prefetch" href="/rust-doc/assets/js/20.b2f37783.js"><link rel="prefetch" href="/rust-doc/assets/js/21.bc7abb0d.js"><link rel="prefetch" href="/rust-doc/assets/js/22.b15740d1.js"><link rel="prefetch" href="/rust-doc/assets/js/23.8b029831.js"><link rel="prefetch" href="/rust-doc/assets/js/24.3123e7b2.js"><link rel="prefetch" href="/rust-doc/assets/js/25.c92ccfb3.js"><link rel="prefetch" href="/rust-doc/assets/js/26.7cf20f6f.js"><link rel="prefetch" href="/rust-doc/assets/js/27.b6484f43.js"><link rel="prefetch" href="/rust-doc/assets/js/28.c5d100db.js"><link rel="prefetch" href="/rust-doc/assets/js/29.7b185968.js"><link rel="prefetch" href="/rust-doc/assets/js/3.bfcba754.js"><link rel="prefetch" href="/rust-doc/assets/js/30.a897f496.js"><link rel="prefetch" href="/rust-doc/assets/js/31.6dca31d5.js"><link rel="prefetch" href="/rust-doc/assets/js/32.6df6713e.js"><link rel="prefetch" href="/rust-doc/assets/js/33.35cbdf5b.js"><link rel="prefetch" href="/rust-doc/assets/js/34.6bf425a5.js"><link rel="prefetch" href="/rust-doc/assets/js/35.251e1b14.js"><link rel="prefetch" href="/rust-doc/assets/js/36.7fe6156d.js"><link rel="prefetch" href="/rust-doc/assets/js/37.2cd0e0de.js"><link rel="prefetch" href="/rust-doc/assets/js/38.4bc88ad1.js"><link rel="prefetch" href="/rust-doc/assets/js/39.25b21d27.js"><link rel="prefetch" href="/rust-doc/assets/js/4.508a9818.js"><link rel="prefetch" href="/rust-doc/assets/js/40.1f8ea623.js"><link rel="prefetch" href="/rust-doc/assets/js/41.a5b3964e.js"><link rel="prefetch" href="/rust-doc/assets/js/42.95550c94.js"><link rel="prefetch" href="/rust-doc/assets/js/43.dbcac583.js"><link rel="prefetch" href="/rust-doc/assets/js/44.05f74594.js"><link rel="prefetch" href="/rust-doc/assets/js/45.8a75ffa2.js"><link rel="prefetch" href="/rust-doc/assets/js/46.5aa1ed7d.js"><link rel="prefetch" href="/rust-doc/assets/js/47.a602c1f1.js"><link rel="prefetch" href="/rust-doc/assets/js/48.98791225.js"><link rel="prefetch" href="/rust-doc/assets/js/49.70739c54.js"><link rel="prefetch" href="/rust-doc/assets/js/5.f95f0a29.js"><link rel="prefetch" href="/rust-doc/assets/js/50.c9ad4e7b.js"><link rel="prefetch" href="/rust-doc/assets/js/51.9a35b992.js"><link rel="prefetch" href="/rust-doc/assets/js/52.0b6b0a5a.js"><link rel="prefetch" href="/rust-doc/assets/js/53.9336e5a4.js"><link rel="prefetch" href="/rust-doc/assets/js/54.c8d8baef.js"><link rel="prefetch" href="/rust-doc/assets/js/56.1a0d24f7.js"><link rel="prefetch" href="/rust-doc/assets/js/57.21a4b27d.js"><link rel="prefetch" href="/rust-doc/assets/js/58.67dc18f7.js"><link rel="prefetch" href="/rust-doc/assets/js/59.6bf39a82.js"><link rel="prefetch" href="/rust-doc/assets/js/6.c4bf9bde.js"><link rel="prefetch" href="/rust-doc/assets/js/60.9c4885f0.js"><link rel="prefetch" href="/rust-doc/assets/js/61.b71c278b.js"><link rel="prefetch" href="/rust-doc/assets/js/62.3a4f0cb7.js"><link rel="prefetch" href="/rust-doc/assets/js/63.0b702afe.js"><link rel="prefetch" href="/rust-doc/assets/js/64.b83541ff.js"><link rel="prefetch" href="/rust-doc/assets/js/65.16a56806.js"><link rel="prefetch" href="/rust-doc/assets/js/66.6afc737f.js"><link rel="prefetch" href="/rust-doc/assets/js/67.c58df2de.js"><link rel="prefetch" href="/rust-doc/assets/js/68.d626fd8e.js"><link rel="prefetch" href="/rust-doc/assets/js/69.295d65b6.js"><link rel="prefetch" href="/rust-doc/assets/js/7.7610c249.js"><link rel="prefetch" href="/rust-doc/assets/js/70.72d45c40.js"><link rel="prefetch" href="/rust-doc/assets/js/71.7b6416c1.js"><link rel="prefetch" href="/rust-doc/assets/js/72.92d12a1c.js"><link rel="prefetch" href="/rust-doc/assets/js/73.935c4d8c.js"><link rel="prefetch" href="/rust-doc/assets/js/74.be7c496c.js"><link rel="prefetch" href="/rust-doc/assets/js/75.a1d63544.js"><link rel="prefetch" href="/rust-doc/assets/js/76.fcb8ac3b.js"><link rel="prefetch" href="/rust-doc/assets/js/77.df6da012.js"><link rel="prefetch" href="/rust-doc/assets/js/78.fb823ebd.js"><link rel="prefetch" href="/rust-doc/assets/js/79.d5c2dab0.js"><link rel="prefetch" href="/rust-doc/assets/js/80.23ebc8ab.js"><link rel="prefetch" href="/rust-doc/assets/js/81.3ecbb346.js"><link rel="prefetch" href="/rust-doc/assets/js/82.cf75df79.js"><link rel="prefetch" href="/rust-doc/assets/js/83.f29d6a08.js"><link rel="prefetch" href="/rust-doc/assets/js/84.738f8523.js"><link rel="prefetch" href="/rust-doc/assets/js/85.9ed79021.js"><link rel="prefetch" href="/rust-doc/assets/js/86.ec0392f3.js"><link rel="prefetch" href="/rust-doc/assets/js/87.18f830b4.js"><link rel="prefetch" href="/rust-doc/assets/js/88.55b82a78.js"><link rel="prefetch" href="/rust-doc/assets/js/89.ed389936.js"><link rel="prefetch" href="/rust-doc/assets/js/90.f1af2708.js"><link rel="prefetch" href="/rust-doc/assets/js/91.6728badf.js"><link rel="prefetch" href="/rust-doc/assets/js/92.1ad17c00.js"><link rel="prefetch" href="/rust-doc/assets/js/93.6c380c9e.js"><link rel="prefetch" href="/rust-doc/assets/js/94.42aa2d98.js"><link rel="prefetch" href="/rust-doc/assets/js/95.434e21fd.js"><link rel="prefetch" href="/rust-doc/assets/js/96.a1179c39.js"><link rel="prefetch" href="/rust-doc/assets/js/97.aabcd77a.js"><link rel="prefetch" href="/rust-doc/assets/js/98.0814f303.js"><link rel="prefetch" href="/rust-doc/assets/js/99.ea606a25.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.3b28fe31.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.b04b0b2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable"><span>认识所有权</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/packages-crates-and-modules/packages-crates-and-modules" class="sidebar-heading clickable"><span>使用包、依赖箱和模块管理不断增长的项目</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-collections/common-collections" class="sidebar-heading clickable"><span>常用集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/error-handling/error-handling" class="sidebar-heading clickable"><span>错误处理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/generics/generics" class="sidebar-heading clickable"><span>泛型类型、特性和生命周期</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/testing/testing" class="sidebar-heading clickable"><span>测试</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/an-io-project/an-io-project" class="sidebar-heading clickable"><span>I/O 项目：构建命令行程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/functional-features/functional-features" class="sidebar-heading clickable"><span>函数式语言特性：迭代器与闭包</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/more-about-cargo/more-about-cargo" class="sidebar-heading clickable"><span>关于 Cargo 和 Crates.io 的更多信息</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/smart-pointers/smart-pointers" class="sidebar-heading clickable"><span>智能指针</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/concurrency/concurrency" class="sidebar-heading clickable"><span>无畏并发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/async-await/async-await" class="sidebar-heading clickable open"><span>异步编程基础：Async、Await、Futures 和 Streams</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/async-await/futures-and-syntax.html" class="sidebar-link">Future 与异步语法</a></li><li><a href="/rust-doc/doc/async-await/concurrency-with-async.html" aria-current="page" class="active sidebar-link">应用异步并发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/async-await/concurrency-with-async.html#应用异步并发" class="sidebar-link">应用异步并发</a></li></ul></li><li><a href="/rust-doc/doc/async-await/more-futures.html" class="sidebar-link">处理任意数量的 Future</a></li><li><a href="/rust-doc/doc/async-await/streams.html" class="sidebar-link">流：按顺序排列的 Future</a></li><li><a href="/rust-doc/doc/async-await/traits-for-async.html" class="sidebar-link">深入了解异步特性</a></li><li><a href="/rust-doc/doc/async-await/futures-tasks-threads.html" class="sidebar-link">整合：Future、任务和线程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/oop/oop" class="sidebar-heading clickable"><span>面向对象编程特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/patterns/patterns" class="sidebar-heading clickable"><span>模式与匹配</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/advanced-features/advanced-features" class="sidebar-heading clickable"><span>高级特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="应用异步并发"><a href="#应用异步并发" class="header-anchor">#</a> 应用异步并发</h2> <p>在本节中，我们将把异步应用到我们在第 16 章中使用线程解决的一些相同并发挑战中。因为我们已经讨论了很多关键思想，所以本节我们将重点关注线程和 Future 之间的区别。</p> <p>在许多情况下，使用异步处理并发的 API 与使用线程的 API 非常相似。在其他情况下，它们最终会大相径庭。即使 API 在线程和异步之间看起来相似，它们通常也具有不同的行为——而且它们几乎总是具有不同的性能特征。</p> <h3 id="使用-spawn-task-创建新任务"><a href="#使用-spawn-task-创建新任务" class="header-anchor">#</a> 使用 <code>spawn_task</code> 创建新任务</h3> <p>我们在<a href="https://doc.rust-lang.org/book/ch16-01-threads.html#creating-a-new-thread-with-spawn" target="_blank" rel="noopener noreferrer">使用 <code>spawn</code> 创建新线程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中解决的第一个操作是在两个单独的线程上计数。让我们使用异步来做同样的事情。<code>trpl</code> crate 提供了一个 <code>spawn_task</code> 函数，它看起来与 <code>thread::spawn</code> API 非常相似，还有一个 <code>sleep</code> 函数，它是 <code>thread::sleep</code> API 的异步版本。我们可以将它们一起使用来实现计数示例，如示例 17-6 所示。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">spawn_task</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">10</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the first task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the second task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-6：创建一个新任务，在主任务打印其他内容时打印一个内容</p> <p>作为起点，我们使用 <code>trpl::run</code> 设置了 <code>main</code> 函数，以便我们的顶级函数可以是异步的。</p> <blockquote><p>注意：从本章的这一点开始，每个示例都将包含与 <code>main</code> 中的 <code>trpl::run</code> 完全相同的包装代码，因此我们通常会像处理 <code>main</code> 一样跳过它。不要忘记将其包含在你的代码中！</p></blockquote> <p>然后我们在此块中编写两个循环，每个循环都包含一个 <code>trpl::sleep</code> 调用，该调用会等待半秒（500 毫秒）然后发送下一条消息。我们将一个循环放在 <code>trpl::spawn_task</code> 的主体中，另一个放在顶层 <code>for</code> 循环中。我们还在 <code>sleep</code> 调用后添加了一个 <code>await</code>。</p> <p>此代码的行为类似于基于线程的实现——包括你在自己的终端中运行它时可能会看到消息以不同顺序出现的事实：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>hi number <span class="token number">1</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">1</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">5</span> from the first <span class="token macro property">task!</span>
</code></pre></div><p>此版本在主异步块中的 <code>for</code> 循环一结束就停止，因为 <code>spawn_task</code> 派生的任务在 <code>main</code> 函数结束时被关闭。如果你希望它一直运行直到任务完成，你将需要使用一个 <code>join</code> 句柄来等待第一个任务完成。对于线程，我们使用 <code>join</code> 方法“阻塞”直到线程运行完成。在示例 17-7 中，我们可以使用 <code>await</code> 来做同样的事情，因为任务句柄本身就是一个 <code>Future</code>。它的 <code>Output</code> 类型是 <code>Result</code>，所以我们在 <code>await</code> 它之后也对其进行 <code>unwrap</code>。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> handle <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">spawn_task</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">10</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the first task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the second task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        handle<span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-7：使用 <code>await</code> 和 <code>join</code> 句柄来运行任务直到完成</p> <p>此更新版本会一直运行直到两个循环都完成。</p> <div class="language-rust extra-class"><pre class="language-rust"><code>hi number <span class="token number">1</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">1</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">5</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">6</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">7</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">8</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">9</span> from the first <span class="token macro property">task!</span>
</code></pre></div><p>到目前为止，异步和线程似乎给我们带来了相同的结果，只是语法不同：使用 <code>await</code> 而不是在 <code>join</code> 句柄上调用 <code>join</code>，以及 <code>await</code> <code>sleep</code> 调用。</p> <p>更大的区别在于我们不需要为此派生另一个操作系统线程。事实上，我们甚至不需要在这里派生一个任务。因为异步块编译为匿名 <code>Future</code>，我们可以将每个循环放在一个异步块中，并让运行时使用 <code>trpl::join</code> 函数将它们都运行完成。</p> <p>在<a href="https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles" target="_blank" rel="noopener noreferrer">使用 <code>join</code> 句柄等待所有线程完成<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一节中，我们展示了如何在调用 <code>std::thread::spawn</code> 时返回的 <code>JoinHandle</code> 类型上使用 <code>join</code> 方法。<code>trpl::join</code> 函数类似，但适用于 <code>Future</code>。当你给它两个 <code>Future</code> 时，它会生成一个新的 <code>Future</code>，其输出是一个元组，其中包含你传入的每个 <code>Future</code> 完成后的输出。因此，在示例 17-8 中，我们使用 <code>trpl::join</code> 来等待 <code>fut1</code> 和 <code>fut2</code> 都完成。我们不 <code>await</code> <code>fut1</code> 和 <code>fut2</code>，而是 <code>await</code> <code>trpl::join</code> 生成的新 <code>Future</code>。我们忽略输出，因为它只是一个包含两个单元值的元组。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> fut1 <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">10</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the first task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> fut2 <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;hi number {i} from the second task!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">join</span><span class="token punctuation">(</span>fut1<span class="token punctuation">,</span> fut2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-8：使用 <code>trpl::join</code> 等待两个匿名 <code>Future</code></p> <p>当我们运行它时，我们看到两个 <code>Future</code> 都运行完成：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>hi number <span class="token number">1</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">1</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">2</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">3</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">4</span> from the second <span class="token macro property">task!</span>
hi number <span class="token number">5</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">6</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">7</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">8</span> from the first <span class="token macro property">task!</span>
hi number <span class="token number">9</span> from the first <span class="token macro property">task!</span>
</code></pre></div><p>现在，你每次都会看到完全相同的顺序，这与我们使用线程时看到的非常不同。这是因为 <code>trpl::join</code> 函数是公平的，这意味着它会平等地检查每个 <code>Future</code>，在它们之间交替，并且如果另一个 <code>Future</code> 准备就绪，它绝不会让一个 <code>Future</code> 领先。对于线程，操作系统决定检查哪个线程以及让它运行多长时间。对于异步 Rust，运行时决定检查哪个任务。（实际上，细节变得复杂，因为异步运行时可能会在底层使用操作系统线程作为其管理并发的一部分，因此保证公平性对于运行时来说可能需要更多的工作——但仍然是可能的！）运行时不必保证任何给定操作的公平性，它们通常提供不同的 API，让你选择是否需要公平性。</p> <p>尝试以下这些等待 <code>Future</code> 的变体，看看它们会做什么：</p> <ul><li>移除一个或两个循环周围的异步块。</li> <li>在定义每个异步块后立即等待它。</li> <li>只将第一个循环包装在一个异步块中，并在第二个循环的主体之后等待生成的 <code>Future</code>。</li></ul> <p>对于额外的挑战，看看你是否能在运行代码之前弄清楚每种情况下的输出会是什么！</p> <h3 id="使用消息传递在两个任务上计数"><a href="#使用消息传递在两个任务上计数" class="header-anchor">#</a> 使用消息传递在两个任务上计数</h3> <p><code>Future</code> 之间的数据共享也会很熟悉：我们将再次使用消息传递，但这次使用异步版本的类型和函数。我们将采取与<a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html" target="_blank" rel="noopener noreferrer">使用消息传递在线程之间传输数据<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中略有不同的路径，以说明基于线程和基于 <code>Future</code> 的并发之间的一些关键区别。在示例 17-9 中，我们将从一个单独的异步块开始——而不是像我们派生单独线程那样派生一个单独的任务。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> received <span class="token operator">=</span> rx<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Got: {received}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-9：创建一个异步通道并将两半分配给 <code>tx</code> 和 <code>rx</code></p> <p>在这里，我们使用 <code>trpl::channel</code>，它是我们在第 16 章中使用线程的多生产者、单消费者通道 API 的异步版本。该 API 的异步版本与基于线程的版本只有一点不同：它使用可变而不是不可变的接收器 <code>rx</code>，并且其 <code>recv</code> 方法会生成一个我们需要 <code>await</code> 的 <code>Future</code>，而不是直接生成值。现在我们可以从发送方向接收方发送消息。请注意，我们不必派生单独的线程甚至任务；我们只需要 <code>await</code> <code>rx.recv</code> 调用。</p> <p><code>std::mpsc::channel</code> 中的同步 <code>Receiver::recv</code> 方法会阻塞直到收到消息。<code>trpl::Receiver::recv</code> 方法不会，因为它是一个异步方法。它不会阻塞，而是将控制权交还给运行时，直到收到消息或通道的发送端关闭。相比之下，我们不 <code>await</code> <code>send</code> 调用，因为它不会阻塞。它不需要阻塞，因为我们发送到的通道是无界的。</p> <blockquote><p>注意：由于所有这些异步代码都在 <code>trpl::run</code> 调用中的异步块中运行，因此其中的所有内容都可以避免阻塞。但是，外部代码将阻塞在 <code>run</code> 函数返回上。这就是 <code>trpl::run</code> 函数的全部意义：它允许你选择在何处阻塞一组异步代码，从而在同步和异步代码之间进行转换。在大多数异步运行时中，<code>run</code> 实际上因此被称为 <code>block_on</code>。</p></blockquote> <p>请注意此示例中的两件事。首先，消息会立即到达。其次，尽管我们在这里使用了一个 <code>Future</code>，但还没有并发。示例中的所有内容都按顺序发生，就像没有 <code>Future</code> 参与一样。</p> <p>让我们通过发送一系列消息并在它们之间休眠来解决第一部分，如示例 17-10 所示。</p> <p>文件名：src/main.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> vals <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
            <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;from&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;the&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;future&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> val <span class="token keyword">in</span> vals <span class="token punctuation">{</span>
            tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span> rx<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;received '{value}'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-10：通过异步通道发送和接收多条消息，并在每条消息之间使用 await 休眠</p> <p>除了发送消息，我们还需要接收它们。在这种情况下，因为我们知道有多少消息会进来，我们可以通过手动调用 <code>rx.recv().await</code> 四次来完成。然而，在实际情况中，我们通常会等待一些未知数量的消息，所以我们需要持续等待，直到我们确定没有更多消息。</p> <p>我们可以使用 <code>while let</code> 循环来做到这一点，如示例 17-11 所示。</p> <p>In Listing 16-10, we used a for loop to process all the items received from a synchronous channel. Rust doesn’t yet have a way to write a for loop over an asynchronous series of items, however, so we need to use a loop we haven’t seen before: the while let conditional loop. This is the loop version of the if let construct we saw back in the section <a href="https://doc.rust-lang.org/book/ch06-03-if-let.html" target="_blank" rel="noopener noreferrer">Concise Control Flow with if let and let else<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. The loop will continue executing as long as the pattern it specifies continues to match the value.</p> <p><code>rx.recv</code> 调用会产生一个 <code>Future</code>，我们对其进行 <code>await</code>。运行时会暂停该 <code>Future</code> 直到它准备就绪。一旦消息到达，该 <code>Future</code> 将解析为 <code>Some(message)</code>，消息到达多少次就解析多少次。当通道关闭时，无论是否有消息到达，该 <code>Future</code> 都将解析为 <code>None</code>，表示没有更多值，因此我们应该停止轮询——即停止 <code>await</code>。</p> <p><code>while let</code> 循环将所有这些结合在一起。如果调用 <code>rx.recv().await</code> 的结果是 <code>Some(message)</code>，我们就可以访问该消息并在循环体中使用它，就像使用 <code>if let</code> 一样。如果结果是 <code>None</code>，循环就结束。每次循环完成时，它都会再次到达 <code>await</code> 点，因此运行时会再次暂停它，直到另一条消息到达。</p> <p>现在代码成功发送和接收所有消息。不幸的是，仍然存在一些问题。首先，消息不是以半秒的间隔到达的。它们在程序启动 2 秒（2000 毫秒）后一次性全部到达。其次，这个程序永远不会退出！相反，它会永远等待新消息。你需要使用 <code>ctrl-c</code> 关闭它。</p> <p>让我们开始研究为什么消息会在完全延迟后一次性全部到达，而不是在每条消息之间都有延迟。在给定的异步块中，<code>await</code> 关键字出现的顺序也是它们在程序运行时执行的顺序。</p> <p>示例 17-10 中只有一个异步块，所以其中的所有内容都是线性运行的。仍然没有并发。所有的 <code>tx.send</code> 调用都会发生，其间穿插着所有的 <code>trpl::sleep</code> 调用及其相关的 <code>await</code> 点。只有这样，<code>while let</code> 循环才能通过 <code>recv</code> 调用上的任何 <code>await</code> 点。</p> <p>为了获得我们想要的行为，即在每条消息之间发生休眠延迟，我们需要将 <code>tx</code> 和 <code>rx</code> 操作放在它们自己的异步块中，如示例 17-11 所示。然后运行时可以使用 <code>trpl::join</code> 分别执行它们，就像计数示例中一样。我们再次 <code>await</code> 调用 <code>trpl::join</code> 的结果，而不是单独的 <code>Future</code>。如果按顺序 <code>await</code> 单独的 <code>Future</code>，我们最终只会回到顺序流中——这正是我们试图避免的。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> tx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> vals <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;from&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;the&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;future&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> val <span class="token keyword">in</span> vals <span class="token punctuation">{</span>
                tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> rx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span> rx<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;received '{value}'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">join</span><span class="token punctuation">(</span>tx_fut<span class="token punctuation">,</span> rx_fut<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-11：将发送和接收分离到它们自己的异步块中，并 <code>await</code> 这些块的 <code>Future</code></p> <p>使用示例 17-11 中更新的代码，消息会以 500 毫秒的间隔打印，而不是在 2 秒后一股脑地全部打印出来。</p> <p>然而，程序仍然不会退出，这是因为 <code>while let</code> 循环与 <code>trpl::join</code> 的交互方式：</p> <ul><li><code>trpl::join</code> 返回的 <code>Future</code> 只有在传递给它的两个 <code>Future</code> 都完成后才会完成。</li> <li><code>tx</code> <code>Future</code> 在发送 <code>vals</code> 中的最后一条消息并休眠结束后完成。</li> <li><code>rx</code> <code>Future</code> 不会完成，直到 <code>while let</code> 循环结束。</li> <li><code>while let</code> 循环不会结束，直到 <code>await</code> <code>rx.recv</code> 产生 <code>None</code>。</li> <li><code>await</code> <code>rx.recv</code> 只有在通道的另一端关闭后才会返回 <code>None</code>。</li> <li>通道只有在我们调用 <code>rx.close</code> 或发送端 <code>tx</code> 被丢弃时才会关闭。</li> <li>我们没有在任何地方调用 <code>rx.close</code>，并且 <code>tx</code> 不会在传递给 <code>trpl::run</code> 的最外层异步块结束之前被丢弃。</li> <li>该块无法结束，因为它被 <code>trpl::join</code> 的完成所阻塞，这又将我们带回了此列表的顶部。</li></ul> <p>我们可以手动关闭 <code>rx</code>，通过在某个地方调用 <code>rx.close</code>，但这没有多大意义。在处理完任意数量的消息后停止会使程序关闭，但我们可能会错过消息。我们需要其他方法来确保 <code>tx</code> 在函数结束之前被丢弃。</p> <p>现在，我们发送消息的异步块只借用了 <code>tx</code>，因为发送消息不需要所有权，但如果我们可以将 <code>tx</code> 移动到该异步块中，那么一旦该块结束，它就会被丢弃。在第 13 章的<a href="https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-references-or-moving-ownership" target="_blank" rel="noopener noreferrer">捕获引用或移动所有权<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一节中，你学习了如何在闭包中使用 <code>move</code> 关键字，并且，正如第 16 章的<a href="https://doc.rust-lang.org/book/ch16-01-threads.html#using-move-closures-with-threads" target="_blank" rel="noopener noreferrer">将 <code>move</code> 闭包与线程一起使用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一节中所讨论的，在使用线程时，我们经常需要将数据移动到闭包中。同样的基本动态也适用于异步块，因此 <code>move</code> 关键字在异步块中的工作方式与在闭包中相同。</p> <p>在示例 17-12 中，我们将用于发送消息的块从 <code>async</code> 更改为 <code>async move</code>。当我们运行此版本的代码时，它会在发送和接收完最后一条消息后优雅地关闭。</p> <p>Filename: src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> tx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">move</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> vals <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;from&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;the&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;future&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> val <span class="token keyword">in</span> vals <span class="token punctuation">{</span>
                tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> rx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span> rx<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;received '{value}'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">join</span><span class="token punctuation">(</span>tx_fut<span class="token punctuation">,</span> rx_fut<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-12：示例 17-11 代码的修订版，完成后正确关闭</p> <p>这个异步通道也是一个多生产者通道，所以如果我们想从多个 <code>Future</code> 发送消息，我们可以在 <code>tx</code> 上调用 <code>clone</code>，如示例 17-13 所示。</p> <p>文件名：src/main.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">trpl</span><span class="token punctuation">;</span> <span class="token comment">// required for mdbook test</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>tx<span class="token punctuation">,</span> <span class="token keyword">mut</span> rx<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> tx1 <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> tx1_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">move</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> vals <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;from&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;the&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;future&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> val <span class="token keyword">in</span> vals <span class="token punctuation">{</span>
                tx1<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> rx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span> rx<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;received '{value}'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> tx_fut <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">move</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> vals <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;more&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;messages&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;for&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;you&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> val <span class="token keyword">in</span> vals <span class="token punctuation">{</span>
                tx<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_millis</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token namespace">trpl<span class="token punctuation">::</span></span><span class="token function">join3</span><span class="token punctuation">(</span>tx1_fut<span class="token punctuation">,</span> tx_fut<span class="token punctuation">,</span> rx_fut<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 17-13：使用异步块的多个生产者</p> <p>首先，我们克隆 <code>tx</code>，在第一个异步块之外创建 <code>tx1</code>。我们将 <code>tx1</code> 移动到该块中，就像我们之前对 <code>tx</code> 所做的那样。然后，我们稍后将原始 <code>tx</code> 移动到一个新的异步块中，在那里我们以稍慢的延迟发送更多消息。我们碰巧将这个新的异步块放在接收消息的异步块之后，但它也可以放在它之前。关键是 <code>Future</code> 被 <code>await</code> 的顺序，而不是它们被创建的顺序。</p> <p>两个用于发送消息的异步块都需要是 <code>async move</code> 块，以便 <code>tx</code> 和 <code>tx1</code> 在这些块完成时都被丢弃。否则，我们将回到我们开始的无限循环中。最后，我们从 <code>trpl::join</code> 切换到 <code>trpl::join3</code> 来处理额外的 <code>Future</code>。</p> <p>现在我们看到了来自两个发送 <code>Future</code> 的所有消息，并且由于发送 <code>Future</code> 在发送后使用了稍微不同的延迟，因此消息也以这些不同的间隔接收。</p> <div class="language-rust extra-class"><pre class="language-rust"><code>received <span class="token lifetime-annotation symbol">'hi</span>'
received <span class="token lifetime-annotation symbol">'more</span>'
received <span class="token lifetime-annotation symbol">'from</span>'
received <span class="token lifetime-annotation symbol">'the</span>'
received <span class="token lifetime-annotation symbol">'messages</span>'
received <span class="token lifetime-annotation symbol">'future</span>'
received <span class="token lifetime-annotation symbol">'for</span>'
received <span class="token lifetime-annotation symbol">'you</span>'
</code></pre></div><p>这是一个好的开始，但它将我们限制在少数几个 <code>Future</code>：两个使用 <code>join</code>，或者三个使用 <code>join3</code>。让我们看看如何处理更多的 <code>Future</code>。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/async-await/futures-and-syntax.html" class="prev">
        Future 与异步语法
      </a></span> <span class="next"><a href="/rust-doc/doc/async-await/more-futures.html">
        处理任意数量的 Future
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.a072e027.js" defer></script><script src="/rust-doc/assets/js/2.de3bffe6.js" defer></script><script src="/rust-doc/assets/js/1.5cc4c8d6.js" defer></script><script src="/rust-doc/assets/js/55.b62f2ebe.js" defer></script>
  </body>
</html>
