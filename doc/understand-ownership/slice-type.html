<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>切片 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.b04b0b2c.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.59ee1127.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.ef01dcaa.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.24d69999.js" as="script"><link rel="preload" href="/rust-doc/assets/js/28.cbb81744.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.54fcb7f2.js"><link rel="prefetch" href="/rust-doc/assets/js/11.34f04bd2.js"><link rel="prefetch" href="/rust-doc/assets/js/12.cfa62d94.js"><link rel="prefetch" href="/rust-doc/assets/js/13.b4997dcb.js"><link rel="prefetch" href="/rust-doc/assets/js/14.dd9039d4.js"><link rel="prefetch" href="/rust-doc/assets/js/15.1cebfd3a.js"><link rel="prefetch" href="/rust-doc/assets/js/16.6c2ae328.js"><link rel="prefetch" href="/rust-doc/assets/js/17.93633265.js"><link rel="prefetch" href="/rust-doc/assets/js/18.000ab2fa.js"><link rel="prefetch" href="/rust-doc/assets/js/19.2ad1313e.js"><link rel="prefetch" href="/rust-doc/assets/js/20.c806ca6e.js"><link rel="prefetch" href="/rust-doc/assets/js/21.016f373b.js"><link rel="prefetch" href="/rust-doc/assets/js/22.48ce6621.js"><link rel="prefetch" href="/rust-doc/assets/js/23.e4372f6d.js"><link rel="prefetch" href="/rust-doc/assets/js/24.a74276c9.js"><link rel="prefetch" href="/rust-doc/assets/js/25.bc413c63.js"><link rel="prefetch" href="/rust-doc/assets/js/26.90de5df6.js"><link rel="prefetch" href="/rust-doc/assets/js/27.16ba5673.js"><link rel="prefetch" href="/rust-doc/assets/js/29.4c7ddbe2.js"><link rel="prefetch" href="/rust-doc/assets/js/3.bee02ab5.js"><link rel="prefetch" href="/rust-doc/assets/js/30.f92b610c.js"><link rel="prefetch" href="/rust-doc/assets/js/31.cf8e7e3b.js"><link rel="prefetch" href="/rust-doc/assets/js/32.8c1ef0cc.js"><link rel="prefetch" href="/rust-doc/assets/js/33.e0090ab9.js"><link rel="prefetch" href="/rust-doc/assets/js/34.d454a4d0.js"><link rel="prefetch" href="/rust-doc/assets/js/35.04811714.js"><link rel="prefetch" href="/rust-doc/assets/js/36.72aeb37e.js"><link rel="prefetch" href="/rust-doc/assets/js/37.4b7e4551.js"><link rel="prefetch" href="/rust-doc/assets/js/38.cf6ec07a.js"><link rel="prefetch" href="/rust-doc/assets/js/39.21f6dc11.js"><link rel="prefetch" href="/rust-doc/assets/js/4.ccfd41e2.js"><link rel="prefetch" href="/rust-doc/assets/js/40.f50dfe68.js"><link rel="prefetch" href="/rust-doc/assets/js/41.65d6ea2e.js"><link rel="prefetch" href="/rust-doc/assets/js/42.918d84da.js"><link rel="prefetch" href="/rust-doc/assets/js/43.dab2b69b.js"><link rel="prefetch" href="/rust-doc/assets/js/44.3c62a866.js"><link rel="prefetch" href="/rust-doc/assets/js/45.e18a0c01.js"><link rel="prefetch" href="/rust-doc/assets/js/46.d39a80c9.js"><link rel="prefetch" href="/rust-doc/assets/js/47.a193e055.js"><link rel="prefetch" href="/rust-doc/assets/js/48.b38da1e6.js"><link rel="prefetch" href="/rust-doc/assets/js/49.f3cec7c2.js"><link rel="prefetch" href="/rust-doc/assets/js/5.597286b3.js"><link rel="prefetch" href="/rust-doc/assets/js/50.c04fb82b.js"><link rel="prefetch" href="/rust-doc/assets/js/51.9363e8f7.js"><link rel="prefetch" href="/rust-doc/assets/js/52.7df4def1.js"><link rel="prefetch" href="/rust-doc/assets/js/53.4883095f.js"><link rel="prefetch" href="/rust-doc/assets/js/54.e9e85ab2.js"><link rel="prefetch" href="/rust-doc/assets/js/55.bffec693.js"><link rel="prefetch" href="/rust-doc/assets/js/56.2dadd97d.js"><link rel="prefetch" href="/rust-doc/assets/js/57.e4ff989b.js"><link rel="prefetch" href="/rust-doc/assets/js/58.8653798d.js"><link rel="prefetch" href="/rust-doc/assets/js/59.cffebb76.js"><link rel="prefetch" href="/rust-doc/assets/js/6.d65c254a.js"><link rel="prefetch" href="/rust-doc/assets/js/60.a9f81416.js"><link rel="prefetch" href="/rust-doc/assets/js/61.be82a262.js"><link rel="prefetch" href="/rust-doc/assets/js/62.965c798c.js"><link rel="prefetch" href="/rust-doc/assets/js/63.8fced106.js"><link rel="prefetch" href="/rust-doc/assets/js/64.90b9e557.js"><link rel="prefetch" href="/rust-doc/assets/js/7.bb14505d.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.a07464bc.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.b04b0b2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable open"><span>认识所有权</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/understand-ownership/what-ownership.html" class="sidebar-link">什么是所有权</a></li><li><a href="/rust-doc/doc/understand-ownership/references-and-borrow.html" class="sidebar-link">引用与借用</a></li><li><a href="/rust-doc/doc/understand-ownership/slice-type.html" aria-current="page" class="active sidebar-link">切片类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/understand-ownership/slice-type.html#切片" class="sidebar-link">切片</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/packages-crates-and-modules/packages-crates-and-modules" class="sidebar-heading clickable"><span>使用包、依赖箱和模块管理不断增长的项目</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-collections/common-collections" class="sidebar-heading clickable"><span>常用集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="切片"><a href="#切片" class="header-anchor">#</a> 切片</h2> <p>切片允许你引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。</p> <p>这是一个小编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中未找到空格，则整个字符串必须是一个单词，因此应返回整个字符串。</p> <p>让我们研究一下如何在不使用切片的情况下编写此函数的签名，以了解切片将解决的 ​​ 问题：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">?</span>
</code></pre></div><p>first_word 函数有一个 &amp;String 作为参数。我们不需要所有权，所以这没问题。但我们应该返回什么呢？我们真的没有办法了解字符串的一部分。但是，我们可以返回单词结尾的索引，用空格表示。让我们尝试一下，如示例 4-7 所示。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-7：first_word 函数将字节索引值返回到 String 参数中</p> <p>因为我们需要逐个遍历元素那样地检查字符串并检查值是否为空格，所以我们将使用 as_bytes 方法将字符串转换为字节数组。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>接下来，我们使用 iter 方法在字节数组上创建一个迭代器：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ....</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们将在第 13 章中更详细地讨论迭代器。现在，知道 iter 是一种返回集合中每个元素的方法，而 enumerate 包装了 iter 的结果并将每个元素作为元组的一部分返回。enumerate 返回的元组的第一个元素是索引，第二个元素是对该元素的引用。这比我们自己计算索引要方便一些。</p> <p>因为 enumerate 方法返回一个元组，所以我们可以使用模式来解构该元组。我们将在第 6 章中进一步讨论模式。在 for 循环中，我们指定一个模式，该模式以 i 为元组中的索引，以 <code>&amp;item</code> 为元组中的单个字节。因为我们从 <code>.iter().enumerate()</code> 获得了对元素的引用，所以我们在模式中使用 <code>&amp;</code>。</p> <p>在 for 循环中，我们使用字节文字语法搜索表示空格的字节。如果找到空格，则返回其位置。否则，我们使用 s.len() 返回字符串的长度。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>现在，我们有了一种方法，可以找出字符串中第一个单词的结尾索引，但有一个问题。我们返回了一个 usize，但它只是 &amp;String 上下文中的一个有意义的数字。换句话说，因为它是一个独立于 String 的值，所以不能保证它在将来仍然有效。考虑示例 4-8 中使用示例 4-7 中的 first_word 函数的程序。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// word 将获得值 5</span>

    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这会清空字符串，使其等于 &quot;&quot;</span>

    <span class="token comment">// word 在此处仍具有值 5，但不再有字符串</span>
    <span class="token comment">// 我们可以有意义地使用值 5。word 现在完全无效！</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-8：存储调用 first_word 函数的结果然后更改字符串内容</p> <p>此程序编译时没有任何错误，如果我们在调用 s.clear() 后使用 word，也会没有任何错误。由于 word 完全不与 s 的状态相关联，因此 word 仍包含值 5。我们可以将值 5 与变量 s 一起使用，以尝试提取出第一个单词，但这会是一个错误，因为自从我们将 5 保存到 word 中后，s 的内容已经发生了变化。</p> <p>担心 word 中的索引与 s 中的数据不同步是一件繁琐且容易出错的事情！如果我们编写一个 second_word 函数，管理这些索引会更加困难。它的签名必须如下所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token keyword">usize</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们正在跟踪起始和结束索引，并且我们拥有更多根据特定状态下的数据计算出来的值，但这些值与该状态完全无关。我们有三个不相关的变量需要保持同步。</p> <p>幸运的是，Rust 为这个问题提供了一个解决方案：字符串切片。</p> <h3 id="字符串切片"><a href="#字符串切片" class="header-anchor">#</a> 字符串切片</h3> <p>字符串切片是对字符串的一部分的引用，它看起来像这样：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>hello 不是对整个字符串的引用，而是对字符串的一部分的引用，在额外的 <code>[0..5]</code> 位中指定。我们通过指定 <code>[starting_index..ending_index]</code> 在括号内使用范围创建切片，其中 starting_index(开始索引) 是切片中的第一个位置，ending_index(结束索引)比切片中的最后一个位置多一个。在内部，切片数据结构存储切片的起始位置和长度，该长度对应于 <code>ending_index</code> 减去 <code>starting_index</code>。因此，在 <code>let world = &amp;s[6..11];</code> 的情况下，world 将是一个切片，其中包含指向 s 索引 6 处的字节的指针，其长度值为 5。</p> <p>图 4-7 以图表形式显示了这一情况。</p> <p><img src="/rust-doc/assets/img/trpl04-07.f5c9b15d.svg" alt="三个表：一个表表示s的堆栈数据，指向堆上字符串数据“hello world”的表中索引0处的字节。第三个表表示切片world的堆栈数据，其长度值为5，指向堆数据表的第6个字节。"></p> <p>图 4-7：字符串切片引用字符串的一部分</p> <p>使用 Rust 的 <code>..</code> 范围语法，如果要从索引 0 开始，可以删除两个句点之前的值。换句话说，它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 与前一行相同！</span>
</code></pre></div><p>同样的道理，如果你的切片包含字符串的最后一个字节，你可以删除尾随的数字。这意味着它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 与前一行相同！</span>
</code></pre></div><p>你还可以删除这两个值以取整个字符串的片段。因此，它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>注意：字符串切片范围索引必须出现在有效的 UTF-8 字符边界处。如果你尝试在多字节字符中间创建字符串切片，程序将退出并出现错误。为了介绍字符串切片，我们在本节中仅假设 ASCII；有关 UTF-8 处理的更详细讨论请参阅第 8 章的“使用字符串存储 UTF-8 编码文本”部分。</p></blockquote> <p>记住所有这些信息后，让我们重写 first_word 以返回一个切片。表示“字符串切片”的类型写为 &amp;str：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们通过查找空格的第一次出现，以与清单 4-7 中相同的方式获取单词结尾的索引。当我们找到空格时，我们使用字符串的开头和空格的索引作为起始和结束索引，返回一个字符串切片。</p> <p>现在，当我们调用 first_word 时，我们会返回一个与底层数据绑定的值。该值由对切片起点的引用和切片中的元素数组成。</p> <p>返回切片也适用于 second_word 函数：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span> 
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们有了一个简单的 API，它更难出错，因为编译器将确保对字符串的引用保持有效。还记得示例 4-8 中程序中的错误吗？当我们将索引移到第一个单词的末尾时，但随后清除了字符串，因此我们的索引无效？该代码在逻辑上是不正确的，但并没有立即显示任何错误。如果我们继续尝试将第一个单词索引与空字符串一起使用，问题将在稍后显示出来。切片使这个错误不可能发生，并让我们更快地知道我们的代码有问题。使用 first_word 的切片版本将引发编译时错误：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;the first word is: {word}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器报错如下：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo run
   <span class="token class-name">Compiling</span> ownership v0<span class="token number">.1</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>file<span class="token punctuation">:</span><span class="token operator">/</span><span class="token comment">//projects/ownership)</span>
error<span class="token punctuation">[</span><span class="token constant">E0502</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `s` <span class="token keyword">as</span> mutable because it is also borrowed <span class="token keyword">as</span> immutable
  <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span><span class="token number">5</span>
   <span class="token operator">|</span>
<span class="token number">16</span> <span class="token operator">|</span>     <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">|</span>                           <span class="token operator">-</span><span class="token operator">-</span> immutable borrow occurs here
<span class="token number">17</span> <span class="token operator">|</span>
<span class="token number">18</span> <span class="token operator">|</span>     s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
   <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> mutable borrow occurs here
<span class="token number">19</span> <span class="token operator">|</span>
<span class="token number">20</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;the first word is: {word}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">|</span>                                  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> immutable borrow later used here

<span class="token class-name">For</span> more information about this error<span class="token punctuation">,</span> <span class="token keyword">try</span> `rustc <span class="token operator">-</span><span class="token operator">-</span>explain <span class="token constant">E0502</span>`<span class="token punctuation">.</span>
error<span class="token punctuation">:</span> could not compile `ownership` <span class="token punctuation">(</span>bin <span class="token string">&quot;ownership&quot;</span><span class="token punctuation">)</span> due to <span class="token number">1</span> previous error
</code></pre></div><p>回想一下借用规则，如果我们对某个对象有一个不可变引用，我们就不能同时获取一个可变引用。因为 clear 需要截断字符串，所以它需要获取一个可变引用。调用 clear 之后的 println! 使用 word 中的引用，因此不可变引用此时必须仍然处于活动状态。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，编译会失败。Rust 不仅使我们的 API 更易于使用，而且还消除了编译时出现的一整类错误！</p> <h4 id="字符串文字作为切片"><a href="#字符串文字作为切片" class="header-anchor">#</a> 字符串文字作为切片</h4> <p>回想一下，我们讨论过字符串文字存储在二进制文件中。现在我们了解了切片，我们可以正确理解字符串文字：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>此处 s 的类型为 <code>&amp;str</code>:它是指向二进制文件特定点的切片。这也是字符串文字不可变的原因；<code>&amp;str</code> 是不可变引用。</p> <h4 id="字符串切片作为参数"><a href="#字符串切片作为参数" class="header-anchor">#</a> 字符串切片作为参数</h4> <p>知道可以对文字和字符串值进行切片后，我们可以对 first_word 进行进一步改进，这就是它的签名：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更有经验的 Rust爱好者 会改写示例 4-9 中所示的签名，因为它允许我们对 <code>&amp;String</code> 值和 <code>&amp;str</code> 值使用相同的函数。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-9：通过使用字符串切片作为 s 参数的类型来改进 first_word 函数</p> <p>如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个字符串，我们可以传递字符串的切片或对字符串的引用。这种灵活性利用了强制解引用，我们将在第 15 章的“使用函数和方法进行隐式强制解引用”部分介绍这一功能。</p> <p>定义一个函数来获取字符串切片而不是对字符串的引用，使我们的 API 更加通用和有用，而不会丢失任何功能：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` 适用于 `String` 的切片，无论是部分切片还是全部切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// `first_word` 还适用于对 `String` 的引用，它们相当于</span>
    <span class="token comment">// 整个 `String` 切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> my_string_literal <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` 适用于字符串文字的切片，无论是部分切片还是全部切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 因为字符串文字已经是字符串切片了，</span>
    <span class="token comment">// 这也行得通，无需切片语法！</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span>my_string_literal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="其它切片"><a href="#其它切片" class="header-anchor">#</a> 其它切片</h3> <p>你可能想象得到，字符串切片特定于字符串。但是还有一种更通用的切片类型。考虑这个数组：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>正如我们可能想要引用字符串的一部分一样，我们可能想要引用数组的一部分。我们可以这样做：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此切片的类型为 <code>&amp;[i32]</code>。它的工作方式与字符串切片相同，即存储对第一个元素的引用和长度。你将使用这种切片来处理各种其他集合。我们将在第 8 章讨论向量时详细讨论这些集合。</p> <p>所有权、借用和切片的概念确保了 Rust 程序在编译时的内存安全。Rust 语言让你可以像其他系统编程语言一样控制内存使用情况，但当数据所有者超出范围时，数据所有者会自动清理数据，这意味着你不必编写和调试额外的代码来获得这种控制。</p> <p>所有权会影响 Rust 许多其他部分的工作方式，因此我们将在本文档的其余部分进一步讨论这些概念。让我们继续第 5 章，看看如何在结构体中将数据片段分组在一起。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/understand-ownership/references-and-borrow.html" class="prev">
        引用与借用
      </a></span> <span class="next"><a href="/rust-doc/doc/structs/defining-structs.html">
        定义和实例化结构体
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.59ee1127.js" defer></script><script src="/rust-doc/assets/js/2.ef01dcaa.js" defer></script><script src="/rust-doc/assets/js/1.24d69999.js" defer></script><script src="/rust-doc/assets/js/28.cbb81744.js" defer></script>
  </body>
</html>
