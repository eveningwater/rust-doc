<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>切片 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.b04b0b2c.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.7d9756f0.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.de3bffe6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.5cc4c8d6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/34.f61f121d.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.eb17c9b1.js"><link rel="prefetch" href="/rust-doc/assets/js/100.b8300857.js"><link rel="prefetch" href="/rust-doc/assets/js/101.cb9746dd.js"><link rel="prefetch" href="/rust-doc/assets/js/102.e470b91d.js"><link rel="prefetch" href="/rust-doc/assets/js/103.c33d52df.js"><link rel="prefetch" href="/rust-doc/assets/js/104.11693b25.js"><link rel="prefetch" href="/rust-doc/assets/js/105.efdd685b.js"><link rel="prefetch" href="/rust-doc/assets/js/106.50578423.js"><link rel="prefetch" href="/rust-doc/assets/js/107.d7653556.js"><link rel="prefetch" href="/rust-doc/assets/js/108.cb651881.js"><link rel="prefetch" href="/rust-doc/assets/js/109.6f0e240c.js"><link rel="prefetch" href="/rust-doc/assets/js/11.4d96857f.js"><link rel="prefetch" href="/rust-doc/assets/js/110.41047ff2.js"><link rel="prefetch" href="/rust-doc/assets/js/111.ae51389e.js"><link rel="prefetch" href="/rust-doc/assets/js/112.637d4c59.js"><link rel="prefetch" href="/rust-doc/assets/js/113.061ad5f6.js"><link rel="prefetch" href="/rust-doc/assets/js/114.251165b9.js"><link rel="prefetch" href="/rust-doc/assets/js/115.598cfe1e.js"><link rel="prefetch" href="/rust-doc/assets/js/116.7d613927.js"><link rel="prefetch" href="/rust-doc/assets/js/117.59b4404a.js"><link rel="prefetch" href="/rust-doc/assets/js/12.0eea138a.js"><link rel="prefetch" href="/rust-doc/assets/js/13.4ea66b16.js"><link rel="prefetch" href="/rust-doc/assets/js/14.c5b4c957.js"><link rel="prefetch" href="/rust-doc/assets/js/15.c72c8a9e.js"><link rel="prefetch" href="/rust-doc/assets/js/16.1c185a04.js"><link rel="prefetch" href="/rust-doc/assets/js/17.b42140fa.js"><link rel="prefetch" href="/rust-doc/assets/js/18.956adef9.js"><link rel="prefetch" href="/rust-doc/assets/js/19.ac65ddaa.js"><link rel="prefetch" href="/rust-doc/assets/js/20.b2f37783.js"><link rel="prefetch" href="/rust-doc/assets/js/21.bc7abb0d.js"><link rel="prefetch" href="/rust-doc/assets/js/22.22dfa4a0.js"><link rel="prefetch" href="/rust-doc/assets/js/23.1aa7dbf5.js"><link rel="prefetch" href="/rust-doc/assets/js/24.3123e7b2.js"><link rel="prefetch" href="/rust-doc/assets/js/25.43f64b7b.js"><link rel="prefetch" href="/rust-doc/assets/js/26.7cf20f6f.js"><link rel="prefetch" href="/rust-doc/assets/js/27.b6484f43.js"><link rel="prefetch" href="/rust-doc/assets/js/28.5f780898.js"><link rel="prefetch" href="/rust-doc/assets/js/29.7b185968.js"><link rel="prefetch" href="/rust-doc/assets/js/3.bfcba754.js"><link rel="prefetch" href="/rust-doc/assets/js/30.ff40b2aa.js"><link rel="prefetch" href="/rust-doc/assets/js/31.0bd4bf73.js"><link rel="prefetch" href="/rust-doc/assets/js/32.d51546af.js"><link rel="prefetch" href="/rust-doc/assets/js/33.d33b828c.js"><link rel="prefetch" href="/rust-doc/assets/js/35.251e1b14.js"><link rel="prefetch" href="/rust-doc/assets/js/36.83c259ce.js"><link rel="prefetch" href="/rust-doc/assets/js/37.f3e1e755.js"><link rel="prefetch" href="/rust-doc/assets/js/38.0101cb76.js"><link rel="prefetch" href="/rust-doc/assets/js/39.fa73527d.js"><link rel="prefetch" href="/rust-doc/assets/js/4.508a9818.js"><link rel="prefetch" href="/rust-doc/assets/js/40.1eb84ff3.js"><link rel="prefetch" href="/rust-doc/assets/js/41.6363c490.js"><link rel="prefetch" href="/rust-doc/assets/js/42.8fa25e33.js"><link rel="prefetch" href="/rust-doc/assets/js/43.be0c300d.js"><link rel="prefetch" href="/rust-doc/assets/js/44.ca51e031.js"><link rel="prefetch" href="/rust-doc/assets/js/45.82784fbd.js"><link rel="prefetch" href="/rust-doc/assets/js/46.d7808969.js"><link rel="prefetch" href="/rust-doc/assets/js/47.d66560c6.js"><link rel="prefetch" href="/rust-doc/assets/js/48.59d859e9.js"><link rel="prefetch" href="/rust-doc/assets/js/49.d43315c6.js"><link rel="prefetch" href="/rust-doc/assets/js/5.f95f0a29.js"><link rel="prefetch" href="/rust-doc/assets/js/50.14acd1e4.js"><link rel="prefetch" href="/rust-doc/assets/js/51.ad5f5bd0.js"><link rel="prefetch" href="/rust-doc/assets/js/52.619e3c13.js"><link rel="prefetch" href="/rust-doc/assets/js/53.f56e4920.js"><link rel="prefetch" href="/rust-doc/assets/js/54.d321ff08.js"><link rel="prefetch" href="/rust-doc/assets/js/55.91c7e639.js"><link rel="prefetch" href="/rust-doc/assets/js/56.6c7b0ede.js"><link rel="prefetch" href="/rust-doc/assets/js/57.5f52612b.js"><link rel="prefetch" href="/rust-doc/assets/js/58.6e0045b4.js"><link rel="prefetch" href="/rust-doc/assets/js/59.f2bb8a08.js"><link rel="prefetch" href="/rust-doc/assets/js/6.c4bf9bde.js"><link rel="prefetch" href="/rust-doc/assets/js/60.eb253920.js"><link rel="prefetch" href="/rust-doc/assets/js/61.3c77c203.js"><link rel="prefetch" href="/rust-doc/assets/js/62.850afab7.js"><link rel="prefetch" href="/rust-doc/assets/js/63.ffde9bdf.js"><link rel="prefetch" href="/rust-doc/assets/js/64.47fe36c4.js"><link rel="prefetch" href="/rust-doc/assets/js/65.a432095e.js"><link rel="prefetch" href="/rust-doc/assets/js/66.99e839c0.js"><link rel="prefetch" href="/rust-doc/assets/js/67.f06e701e.js"><link rel="prefetch" href="/rust-doc/assets/js/68.175b30a4.js"><link rel="prefetch" href="/rust-doc/assets/js/69.660928b8.js"><link rel="prefetch" href="/rust-doc/assets/js/7.7610c249.js"><link rel="prefetch" href="/rust-doc/assets/js/70.ee05e42c.js"><link rel="prefetch" href="/rust-doc/assets/js/71.3993e2fb.js"><link rel="prefetch" href="/rust-doc/assets/js/72.16225025.js"><link rel="prefetch" href="/rust-doc/assets/js/73.1f1649ee.js"><link rel="prefetch" href="/rust-doc/assets/js/74.14f18397.js"><link rel="prefetch" href="/rust-doc/assets/js/75.eb51a247.js"><link rel="prefetch" href="/rust-doc/assets/js/76.ea8105d3.js"><link rel="prefetch" href="/rust-doc/assets/js/77.f9daeef7.js"><link rel="prefetch" href="/rust-doc/assets/js/78.067a20d9.js"><link rel="prefetch" href="/rust-doc/assets/js/79.6da01008.js"><link rel="prefetch" href="/rust-doc/assets/js/80.8027ae78.js"><link rel="prefetch" href="/rust-doc/assets/js/81.8369ad38.js"><link rel="prefetch" href="/rust-doc/assets/js/82.584f45e8.js"><link rel="prefetch" href="/rust-doc/assets/js/83.e65ee11b.js"><link rel="prefetch" href="/rust-doc/assets/js/84.75438fc0.js"><link rel="prefetch" href="/rust-doc/assets/js/85.d1e1afd4.js"><link rel="prefetch" href="/rust-doc/assets/js/86.03a3ca37.js"><link rel="prefetch" href="/rust-doc/assets/js/87.b5799a20.js"><link rel="prefetch" href="/rust-doc/assets/js/88.2a2b5211.js"><link rel="prefetch" href="/rust-doc/assets/js/89.5d8d1398.js"><link rel="prefetch" href="/rust-doc/assets/js/90.c63d24d6.js"><link rel="prefetch" href="/rust-doc/assets/js/91.a62b0468.js"><link rel="prefetch" href="/rust-doc/assets/js/92.12522743.js"><link rel="prefetch" href="/rust-doc/assets/js/93.d780957d.js"><link rel="prefetch" href="/rust-doc/assets/js/94.41633479.js"><link rel="prefetch" href="/rust-doc/assets/js/95.187af548.js"><link rel="prefetch" href="/rust-doc/assets/js/96.9dd28b0c.js"><link rel="prefetch" href="/rust-doc/assets/js/97.fea90625.js"><link rel="prefetch" href="/rust-doc/assets/js/98.b3b7df6f.js"><link rel="prefetch" href="/rust-doc/assets/js/99.24180086.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.3b28fe31.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.b04b0b2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable open"><span>认识所有权</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/understand-ownership/what-ownership.html" class="sidebar-link">什么是所有权</a></li><li><a href="/rust-doc/doc/understand-ownership/references-and-borrow.html" class="sidebar-link">引用与借用</a></li><li><a href="/rust-doc/doc/understand-ownership/slice-type.html" aria-current="page" class="active sidebar-link">切片类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/understand-ownership/slice-type.html#切片" class="sidebar-link">切片</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/packages-crates-and-modules/packages-crates-and-modules" class="sidebar-heading clickable"><span>使用包、依赖箱和模块管理不断增长的项目</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-collections/common-collections" class="sidebar-heading clickable"><span>常用集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/error-handling/error-handling" class="sidebar-heading clickable"><span>错误处理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/generics/generics" class="sidebar-heading clickable"><span>泛型类型、特性和生命周期</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/testing/testing" class="sidebar-heading clickable"><span>测试</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/an-io-project/an-io-project" class="sidebar-heading clickable"><span>I/O 项目：构建命令行程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/functional-features/functional-features" class="sidebar-heading clickable"><span>函数式语言特性：迭代器与闭包</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/more-about-cargo/more-about-cargo" class="sidebar-heading clickable"><span>关于 Cargo 和 Crates.io 的更多信息</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/smart-pointers/smart-pointers" class="sidebar-heading clickable"><span>智能指针</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/concurrency/concurrency" class="sidebar-heading clickable"><span>无畏并发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/async-await/async-await" class="sidebar-heading clickable"><span>异步编程基础：Async、Await、Futures 和 Streams</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/oop/oop" class="sidebar-heading clickable"><span>面向对象编程特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="切片"><a href="#切片" class="header-anchor">#</a> 切片</h2> <p>切片允许你引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。</p> <p>这是一个小编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中未找到空格，则整个字符串必须是一个单词，因此应返回整个字符串。</p> <p>让我们研究一下如何在不使用切片的情况下编写此函数的签名，以了解切片将解决的 ​​ 问题：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">?</span>
</code></pre></div><p>first_word 函数有一个 &amp;String 作为参数。我们不需要所有权，所以这没问题。但我们应该返回什么呢？我们真的没有办法了解字符串的一部分。但是，我们可以返回单词结尾的索引，用空格表示。让我们尝试一下，如示例 4-7 所示。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-7：first_word 函数将字节索引值返回到 String 参数中</p> <p>因为我们需要逐个遍历元素那样地检查字符串并检查值是否为空格，所以我们将使用 as_bytes 方法将字符串转换为字节数组。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>接下来，我们使用 iter 方法在字节数组上创建一个迭代器：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ....</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们将在第 13 章中更详细地讨论迭代器。现在，知道 iter 是一种返回集合中每个元素的方法，而 enumerate 包装了 iter 的结果并将每个元素作为元组的一部分返回。enumerate 返回的元组的第一个元素是索引，第二个元素是对该元素的引用。这比我们自己计算索引要方便一些。</p> <p>因为 enumerate 方法返回一个元组，所以我们可以使用模式来解构该元组。我们将在第 6 章中进一步讨论模式。在 for 循环中，我们指定一个模式，该模式以 i 为元组中的索引，以 <code>&amp;item</code> 为元组中的单个字节。因为我们从 <code>.iter().enumerate()</code> 获得了对元素的引用，所以我们在模式中使用 <code>&amp;</code>。</p> <p>在 for 循环中，我们使用字节文字语法搜索表示空格的字节。如果找到空格，则返回其位置。否则，我们使用 s.len() 返回字符串的长度。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>现在，我们有了一种方法，可以找出字符串中第一个单词的结尾索引，但有一个问题。我们返回了一个 usize，但它只是 &amp;String 上下文中的一个有意义的数字。换句话说，因为它是一个独立于 String 的值，所以不能保证它在将来仍然有效。考虑示例 4-8 中使用示例 4-7 中的 first_word 函数的程序。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// word 将获得值 5</span>

    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这会清空字符串，使其等于 &quot;&quot;</span>

    <span class="token comment">// word 在此处仍具有值 5，但不再有字符串</span>
    <span class="token comment">// 我们可以有意义地使用值 5。word 现在完全无效！</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-8：存储调用 first_word 函数的结果然后更改字符串内容</p> <p>此程序编译时没有任何错误，如果我们在调用 s.clear() 后使用 word，也会没有任何错误。由于 word 完全不与 s 的状态相关联，因此 word 仍包含值 5。我们可以将值 5 与变量 s 一起使用，以尝试提取出第一个单词，但这会是一个错误，因为自从我们将 5 保存到 word 中后，s 的内容已经发生了变化。</p> <p>担心 word 中的索引与 s 中的数据不同步是一件繁琐且容易出错的事情！如果我们编写一个 second_word 函数，管理这些索引会更加困难。它的签名必须如下所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token keyword">usize</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们正在跟踪起始和结束索引，并且我们拥有更多根据特定状态下的数据计算出来的值，但这些值与该状态完全无关。我们有三个不相关的变量需要保持同步。</p> <p>幸运的是，Rust 为这个问题提供了一个解决方案：字符串切片。</p> <h3 id="字符串切片"><a href="#字符串切片" class="header-anchor">#</a> 字符串切片</h3> <p>字符串切片是对字符串的一部分的引用，它看起来像这样：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>hello 不是对整个字符串的引用，而是对字符串的一部分的引用，在额外的 <code>[0..5]</code> 位中指定。我们通过指定 <code>[starting_index..ending_index]</code> 在括号内使用范围创建切片，其中 starting_index(开始索引) 是切片中的第一个位置，ending_index(结束索引)比切片中的最后一个位置多一个。在内部，切片数据结构存储切片的起始位置和长度，该长度对应于 <code>ending_index</code> 减去 <code>starting_index</code>。因此，在 <code>let world = &amp;s[6..11];</code> 的情况下，world 将是一个切片，其中包含指向 s 索引 6 处的字节的指针，其长度值为 5。</p> <p>图 4-7 以图表形式显示了这一情况。</p> <p><img src="/rust-doc/assets/img/trpl04-07.f5c9b15d.svg" alt="三个表：一个表表示s的堆栈数据，指向堆上字符串数据“hello world”的表中索引0处的字节。第三个表表示切片world的堆栈数据，其长度值为5，指向堆数据表的第6个字节。"></p> <p>图 4-7：字符串切片引用字符串的一部分</p> <p>使用 Rust 的 <code>..</code> 范围语法，如果要从索引 0 开始，可以删除两个句点之前的值。换句话说，它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 与前一行相同！</span>
</code></pre></div><p>同样的道理，如果你的切片包含字符串的最后一个字节，你可以删除尾随的数字。这意味着它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 与前一行相同！</span>
</code></pre></div><p>你还可以删除这两个值以取整个字符串的片段。因此，它们是相等的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>注意：字符串切片范围索引必须出现在有效的 UTF-8 字符边界处。如果你尝试在多字节字符中间创建字符串切片，程序将退出并出现错误。为了介绍字符串切片，我们在本节中仅假设 ASCII；有关 UTF-8 处理的更详细讨论请参阅第 8 章的“使用字符串存储 UTF-8 编码文本”部分。</p></blockquote> <p>记住所有这些信息后，让我们重写 first_word 以返回一个切片。表示“字符串切片”的类型写为 &amp;str：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们通过查找空格的第一次出现，以与示例 4-7 中相同的方式获取单词结尾的索引。当我们找到空格时，我们使用字符串的开头和空格的索引作为起始和结束索引，返回一个字符串切片。</p> <p>现在，当我们调用 first_word 时，我们会返回一个与底层数据绑定的值。该值由对切片起点的引用和切片中的元素数组成。</p> <p>返回切片也适用于 second_word 函数：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span> 
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们有了一个简单的 API，它更难出错，因为编译器将确保对字符串的引用保持有效。还记得示例 4-8 中程序中的错误吗？当我们将索引移到第一个单词的末尾时，但随后清除了字符串，因此我们的索引无效？该代码在逻辑上是不正确的，但并没有立即显示任何错误。如果我们继续尝试将第一个单词索引与空字符串一起使用，问题将在稍后显示出来。切片使这个错误不可能发生，并让我们更快地知道我们的代码有问题。使用 first_word 的切片版本将引发编译时错误：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;the first word is: {word}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器报错如下：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo run
   <span class="token class-name">Compiling</span> ownership v0<span class="token number">.1</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>file<span class="token punctuation">:</span><span class="token operator">/</span><span class="token comment">//projects/ownership)</span>
error<span class="token punctuation">[</span><span class="token constant">E0502</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `s` <span class="token keyword">as</span> mutable because it is also borrowed <span class="token keyword">as</span> immutable
  <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span><span class="token number">5</span>
   <span class="token operator">|</span>
<span class="token number">16</span> <span class="token operator">|</span>     <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">|</span>                           <span class="token operator">-</span><span class="token operator">-</span> immutable borrow occurs here
<span class="token number">17</span> <span class="token operator">|</span>
<span class="token number">18</span> <span class="token operator">|</span>     s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
   <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> mutable borrow occurs here
<span class="token number">19</span> <span class="token operator">|</span>
<span class="token number">20</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;the first word is: {word}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">|</span>                                  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> immutable borrow later used here

<span class="token class-name">For</span> more information about this error<span class="token punctuation">,</span> <span class="token keyword">try</span> `rustc <span class="token operator">-</span><span class="token operator">-</span>explain <span class="token constant">E0502</span>`<span class="token punctuation">.</span>
error<span class="token punctuation">:</span> could not compile `ownership` <span class="token punctuation">(</span>bin <span class="token string">&quot;ownership&quot;</span><span class="token punctuation">)</span> due to <span class="token number">1</span> previous error
</code></pre></div><p>回想一下借用规则，如果我们对某个对象有一个不可变引用，我们就不能同时获取一个可变引用。因为 clear 需要截断字符串，所以它需要获取一个可变引用。调用 clear 之后的 println! 使用 word 中的引用，因此不可变引用此时必须仍然处于活动状态。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，编译会失败。Rust 不仅使我们的 API 更易于使用，而且还消除了编译时出现的一整类错误！</p> <h4 id="字符串文字作为切片"><a href="#字符串文字作为切片" class="header-anchor">#</a> 字符串文字作为切片</h4> <p>回想一下，我们讨论过字符串文字存储在二进制文件中。现在我们了解了切片，我们可以正确理解字符串文字：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>此处 s 的类型为 <code>&amp;str</code>:它是指向二进制文件特定点的切片。这也是字符串文字不可变的原因；<code>&amp;str</code> 是不可变引用。</p> <h4 id="字符串切片作为参数"><a href="#字符串切片作为参数" class="header-anchor">#</a> 字符串切片作为参数</h4> <p>知道可以对文字和字符串值进行切片后，我们可以对 first_word 进行进一步改进，这就是它的签名：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更有经验的 Rust爱好者 会改写示例 4-9 中所示的签名，因为它允许我们对 <code>&amp;String</code> 值和 <code>&amp;str</code> 值使用相同的函数。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 4-9：通过使用字符串切片作为 s 参数的类型来改进 first_word 函数</p> <p>如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个字符串，我们可以传递字符串的切片或对字符串的引用。这种灵活性利用了强制解引用，我们将在第 15 章的“使用函数和方法进行隐式强制解引用”部分介绍这一功能。</p> <p>定义一个函数来获取字符串切片而不是对字符串的引用，使我们的 API 更加通用和有用，而不会丢失任何功能：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` 适用于 `String` 的切片，无论是部分切片还是全部切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// `first_word` 还适用于对 `String` 的引用，它们相当于</span>
    <span class="token comment">// 整个 `String` 切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> my_string_literal <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` 适用于字符串文字的切片，无论是部分切片还是全部切片</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 因为字符串文字已经是字符串切片了，</span>
    <span class="token comment">// 这也行得通，无需切片语法！</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span>my_string_literal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="其它切片"><a href="#其它切片" class="header-anchor">#</a> 其它切片</h3> <p>你可能想象得到，字符串切片特定于字符串。但是还有一种更通用的切片类型。考虑这个数组：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>正如我们可能想要引用字符串的一部分一样，我们可能想要引用数组的一部分。我们可以这样做：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此切片的类型为 <code>&amp;[i32]</code>。它的工作方式与字符串切片相同，即存储对第一个元素的引用和长度。你将使用这种切片来处理各种其他集合。我们将在第 8 章讨论向量时详细讨论这些集合。</p> <p>所有权、借用和切片的概念确保了 Rust 程序在编译时的内存安全。Rust 语言让你可以像其他系统编程语言一样控制内存使用情况，但当数据所有者超出范围时，数据所有者会自动清理数据，这意味着你不必编写和调试额外的代码来获得这种控制。</p> <p>所有权会影响 Rust 许多其他部分的工作方式，因此我们将在本文档的其余部分进一步讨论这些概念。让我们继续第 5 章，看看如何在结构体中将数据片段分组在一起。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/understand-ownership/references-and-borrow.html" class="prev">
        引用与借用
      </a></span> <span class="next"><a href="/rust-doc/doc/structs/defining-structs.html">
        定义和实例化结构体
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.7d9756f0.js" defer></script><script src="/rust-doc/assets/js/2.de3bffe6.js" defer></script><script src="/rust-doc/assets/js/1.5cc4c8d6.js" defer></script><script src="/rust-doc/assets/js/34.f61f121d.js" defer></script>
  </body>
</html>
