<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>宏 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.b04b0b2c.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.f0d374f6.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.f80c1e3f.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.fd67daac.js" as="script"><link rel="preload" href="/rust-doc/assets/js/41.c051920d.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.eb17c9b1.js"><link rel="prefetch" href="/rust-doc/assets/js/100.fefafa9b.js"><link rel="prefetch" href="/rust-doc/assets/js/101.17ee2c97.js"><link rel="prefetch" href="/rust-doc/assets/js/102.348689f8.js"><link rel="prefetch" href="/rust-doc/assets/js/103.b1fc7e8c.js"><link rel="prefetch" href="/rust-doc/assets/js/104.3183edc5.js"><link rel="prefetch" href="/rust-doc/assets/js/105.a6cc6f0f.js"><link rel="prefetch" href="/rust-doc/assets/js/106.ffb0a0de.js"><link rel="prefetch" href="/rust-doc/assets/js/107.0ce758b4.js"><link rel="prefetch" href="/rust-doc/assets/js/108.1da873f8.js"><link rel="prefetch" href="/rust-doc/assets/js/109.d28576a3.js"><link rel="prefetch" href="/rust-doc/assets/js/11.4d96857f.js"><link rel="prefetch" href="/rust-doc/assets/js/110.714de49b.js"><link rel="prefetch" href="/rust-doc/assets/js/111.f34ee52d.js"><link rel="prefetch" href="/rust-doc/assets/js/112.150389e0.js"><link rel="prefetch" href="/rust-doc/assets/js/113.c600da56.js"><link rel="prefetch" href="/rust-doc/assets/js/114.8dd55411.js"><link rel="prefetch" href="/rust-doc/assets/js/115.d81d1edd.js"><link rel="prefetch" href="/rust-doc/assets/js/116.589a38c1.js"><link rel="prefetch" href="/rust-doc/assets/js/117.df8467d8.js"><link rel="prefetch" href="/rust-doc/assets/js/118.c981eed9.js"><link rel="prefetch" href="/rust-doc/assets/js/119.82c7f0ad.js"><link rel="prefetch" href="/rust-doc/assets/js/12.0eea138a.js"><link rel="prefetch" href="/rust-doc/assets/js/120.f0a989fe.js"><link rel="prefetch" href="/rust-doc/assets/js/121.5b3a830f.js"><link rel="prefetch" href="/rust-doc/assets/js/122.36b7633b.js"><link rel="prefetch" href="/rust-doc/assets/js/123.cb56d684.js"><link rel="prefetch" href="/rust-doc/assets/js/124.4a94c2a7.js"><link rel="prefetch" href="/rust-doc/assets/js/125.2da7eeab.js"><link rel="prefetch" href="/rust-doc/assets/js/126.c8929e44.js"><link rel="prefetch" href="/rust-doc/assets/js/127.8fb0f7a0.js"><link rel="prefetch" href="/rust-doc/assets/js/128.dd80d591.js"><link rel="prefetch" href="/rust-doc/assets/js/129.aa170fe9.js"><link rel="prefetch" href="/rust-doc/assets/js/13.4e4de3f9.js"><link rel="prefetch" href="/rust-doc/assets/js/130.db8c6071.js"><link rel="prefetch" href="/rust-doc/assets/js/131.93d3925a.js"><link rel="prefetch" href="/rust-doc/assets/js/14.7d8cc8c4.js"><link rel="prefetch" href="/rust-doc/assets/js/15.c72c8a9e.js"><link rel="prefetch" href="/rust-doc/assets/js/16.d49862cf.js"><link rel="prefetch" href="/rust-doc/assets/js/17.c084fb46.js"><link rel="prefetch" href="/rust-doc/assets/js/18.61b146cc.js"><link rel="prefetch" href="/rust-doc/assets/js/19.ac65ddaa.js"><link rel="prefetch" href="/rust-doc/assets/js/20.b2f37783.js"><link rel="prefetch" href="/rust-doc/assets/js/21.bc7abb0d.js"><link rel="prefetch" href="/rust-doc/assets/js/22.2dd10b21.js"><link rel="prefetch" href="/rust-doc/assets/js/23.55de02b6.js"><link rel="prefetch" href="/rust-doc/assets/js/24.3123e7b2.js"><link rel="prefetch" href="/rust-doc/assets/js/25.c2d4d2c7.js"><link rel="prefetch" href="/rust-doc/assets/js/26.7cf20f6f.js"><link rel="prefetch" href="/rust-doc/assets/js/27.b6484f43.js"><link rel="prefetch" href="/rust-doc/assets/js/28.a022eff5.js"><link rel="prefetch" href="/rust-doc/assets/js/29.7b185968.js"><link rel="prefetch" href="/rust-doc/assets/js/3.bfcba754.js"><link rel="prefetch" href="/rust-doc/assets/js/30.4186c23c.js"><link rel="prefetch" href="/rust-doc/assets/js/31.813b9678.js"><link rel="prefetch" href="/rust-doc/assets/js/32.44491046.js"><link rel="prefetch" href="/rust-doc/assets/js/33.52d1bd4d.js"><link rel="prefetch" href="/rust-doc/assets/js/34.322d9308.js"><link rel="prefetch" href="/rust-doc/assets/js/35.ca435b08.js"><link rel="prefetch" href="/rust-doc/assets/js/36.c5e7b3e2.js"><link rel="prefetch" href="/rust-doc/assets/js/37.4b0c4e3a.js"><link rel="prefetch" href="/rust-doc/assets/js/38.176b7420.js"><link rel="prefetch" href="/rust-doc/assets/js/39.ac4964b1.js"><link rel="prefetch" href="/rust-doc/assets/js/4.0d286bf5.js"><link rel="prefetch" href="/rust-doc/assets/js/40.b5016b37.js"><link rel="prefetch" href="/rust-doc/assets/js/42.b1e880d5.js"><link rel="prefetch" href="/rust-doc/assets/js/43.4061a648.js"><link rel="prefetch" href="/rust-doc/assets/js/44.b6ce63a6.js"><link rel="prefetch" href="/rust-doc/assets/js/45.778e0931.js"><link rel="prefetch" href="/rust-doc/assets/js/46.75468c64.js"><link rel="prefetch" href="/rust-doc/assets/js/47.2c1e1a10.js"><link rel="prefetch" href="/rust-doc/assets/js/48.35f9f3e6.js"><link rel="prefetch" href="/rust-doc/assets/js/49.1ee52dfa.js"><link rel="prefetch" href="/rust-doc/assets/js/5.1658b7c6.js"><link rel="prefetch" href="/rust-doc/assets/js/50.2ad6c5d5.js"><link rel="prefetch" href="/rust-doc/assets/js/51.18a069ec.js"><link rel="prefetch" href="/rust-doc/assets/js/52.59cb67e0.js"><link rel="prefetch" href="/rust-doc/assets/js/53.0d9d34de.js"><link rel="prefetch" href="/rust-doc/assets/js/54.0a9fe69b.js"><link rel="prefetch" href="/rust-doc/assets/js/55.a30e4a64.js"><link rel="prefetch" href="/rust-doc/assets/js/56.5df943c5.js"><link rel="prefetch" href="/rust-doc/assets/js/57.f44ee57f.js"><link rel="prefetch" href="/rust-doc/assets/js/58.34af13bf.js"><link rel="prefetch" href="/rust-doc/assets/js/59.dab934fe.js"><link rel="prefetch" href="/rust-doc/assets/js/6.6bd8219b.js"><link rel="prefetch" href="/rust-doc/assets/js/60.5b5aefde.js"><link rel="prefetch" href="/rust-doc/assets/js/61.cc30625c.js"><link rel="prefetch" href="/rust-doc/assets/js/62.57791b4d.js"><link rel="prefetch" href="/rust-doc/assets/js/63.d10762f6.js"><link rel="prefetch" href="/rust-doc/assets/js/64.dc64731f.js"><link rel="prefetch" href="/rust-doc/assets/js/65.4ee2306c.js"><link rel="prefetch" href="/rust-doc/assets/js/66.f1a99e1f.js"><link rel="prefetch" href="/rust-doc/assets/js/67.6903a840.js"><link rel="prefetch" href="/rust-doc/assets/js/68.efc3417d.js"><link rel="prefetch" href="/rust-doc/assets/js/69.4c361eff.js"><link rel="prefetch" href="/rust-doc/assets/js/7.76c11fc1.js"><link rel="prefetch" href="/rust-doc/assets/js/70.5f433f05.js"><link rel="prefetch" href="/rust-doc/assets/js/71.e7030c67.js"><link rel="prefetch" href="/rust-doc/assets/js/72.cc994ed8.js"><link rel="prefetch" href="/rust-doc/assets/js/73.16e1c3d6.js"><link rel="prefetch" href="/rust-doc/assets/js/74.8dde486e.js"><link rel="prefetch" href="/rust-doc/assets/js/75.00a1c9ed.js"><link rel="prefetch" href="/rust-doc/assets/js/76.7b27ad89.js"><link rel="prefetch" href="/rust-doc/assets/js/77.537c5d96.js"><link rel="prefetch" href="/rust-doc/assets/js/78.d5ec6a76.js"><link rel="prefetch" href="/rust-doc/assets/js/79.485d89fb.js"><link rel="prefetch" href="/rust-doc/assets/js/80.49855892.js"><link rel="prefetch" href="/rust-doc/assets/js/81.ebe811b5.js"><link rel="prefetch" href="/rust-doc/assets/js/82.35ef98d5.js"><link rel="prefetch" href="/rust-doc/assets/js/83.442f1239.js"><link rel="prefetch" href="/rust-doc/assets/js/84.a2c5694c.js"><link rel="prefetch" href="/rust-doc/assets/js/85.186197b8.js"><link rel="prefetch" href="/rust-doc/assets/js/86.1ce0ee03.js"><link rel="prefetch" href="/rust-doc/assets/js/87.16afe7d6.js"><link rel="prefetch" href="/rust-doc/assets/js/88.38fc6f23.js"><link rel="prefetch" href="/rust-doc/assets/js/89.7e4e8cf3.js"><link rel="prefetch" href="/rust-doc/assets/js/90.9a764995.js"><link rel="prefetch" href="/rust-doc/assets/js/91.59e310ba.js"><link rel="prefetch" href="/rust-doc/assets/js/92.bf258199.js"><link rel="prefetch" href="/rust-doc/assets/js/93.bbef4287.js"><link rel="prefetch" href="/rust-doc/assets/js/94.1aeb268a.js"><link rel="prefetch" href="/rust-doc/assets/js/95.d20aa01a.js"><link rel="prefetch" href="/rust-doc/assets/js/96.1c2ac11b.js"><link rel="prefetch" href="/rust-doc/assets/js/97.f8400bd1.js"><link rel="prefetch" href="/rust-doc/assets/js/98.8cb332e9.js"><link rel="prefetch" href="/rust-doc/assets/js/99.3cf0cdd5.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.5da1c945.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.b04b0b2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable"><span>认识所有权</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/packages-crates-and-modules/packages-crates-and-modules" class="sidebar-heading clickable"><span>使用包、依赖箱和模块管理不断增长的项目</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-collections/common-collections" class="sidebar-heading clickable"><span>常用集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/error-handling/error-handling" class="sidebar-heading clickable"><span>错误处理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/generics/generics" class="sidebar-heading clickable"><span>泛型类型、特性和生命周期</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/testing/testing" class="sidebar-heading clickable"><span>测试</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/an-io-project/an-io-project" class="sidebar-heading clickable"><span>I/O 项目：构建命令行程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/functional-features/functional-features" class="sidebar-heading clickable"><span>函数式语言特性：迭代器与闭包</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/more-about-cargo/more-about-cargo" class="sidebar-heading clickable"><span>关于 Cargo 和 Crates.io 的更多信息</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/smart-pointers/smart-pointers" class="sidebar-heading clickable"><span>智能指针</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/concurrency/concurrency" class="sidebar-heading clickable"><span>无畏并发</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/async-await/async-await" class="sidebar-heading clickable"><span>异步编程基础：Async、Await、Futures 和 Streams</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/oop/oop" class="sidebar-heading clickable"><span>面向对象编程特性</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/patterns/patterns" class="sidebar-heading clickable"><span>模式与匹配</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/advanced-features/advanced-features" class="sidebar-heading clickable open"><span>高级特性</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/advanced-features/unsafe-rust.html" class="sidebar-link">不安全的rust</a></li><li><a href="/rust-doc/doc/advanced-features/advanced-traits.html" class="sidebar-link">高级特征</a></li><li><a href="/rust-doc/doc/advanced-features/advanced-types.html" class="sidebar-link">高级类型</a></li><li><a href="/rust-doc/doc/advanced-features/advanced-functions-and-closures.html" class="sidebar-link">高级函数和闭包</a></li><li><a href="/rust-doc/doc/advanced-features/macros.html" aria-current="page" class="active sidebar-link">宏</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/advanced-features/macros.html#宏" class="sidebar-link">宏</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/final-project/final-project" class="sidebar-heading clickable"><span>最终项目：构建多线程Web服务器</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="宏"><a href="#宏" class="header-anchor">#</a> 宏</h2> <p>我们在本文档网站中一直使用像<code>println!</code>这样的宏，但我们还没有完全探索宏是什么以及它是如何工作的。术语宏指的是Rust中的一系列功能：带有<code>macro_rules!</code>的声明式宏和三种过程宏：</p> <ul><li>自定义<code>#[derive]</code>宏，指定与在<code>struct</code>和<code>enum</code>上使用的<code>derive</code>属性一起添加的代码</li> <li>类似属性的宏，定义可在任何项上使用的自定义属性</li> <li>类似函数的宏，看起来像函数调用，但对指定为其参数的<code>token</code>进行操作</li></ul> <p>我们将依次讨论这些内容，但首先，让我们看看当我们已经有函数时，为什么我们还需要宏。</p> <h3 id="宏和函数之间的区别"><a href="#宏和函数之间的区别" class="header-anchor">#</a> 宏和函数之间的区别</h3> <p>从根本上说，宏是一种编写代码来编写其他代码的方式，这被称为元编程。在附录C中，我们讨论了<code>derive</code>属性，它为你生成各种<code>trait</code>的实现。我们在整本文档网站中也使用了<code>println!</code>和<code>vec!</code>宏。所有这些宏都会展开以生成比你手动编写的代码更多的代码。</p> <p>元编程对于减少你必须编写和维护的代码数量很有用，这也是函数的作用之一。然而，宏有一些函数没有的额外功能。</p> <p>函数签名必须声明函数具有的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用<code>println!(&quot;hello&quot;)</code>，或者用两个参数调用<code>println!(&quot;hello {}&quot;, name)</code>。此外，宏在编译器解释代码含义之前展开，因此宏可以，例如，在给定类型上实现<code>trait</code>。函数不能这样做，因为它在运行时被调用，而<code>trait</code>需要在编译时实现。</p> <p>实现宏而不是函数的缺点是宏定义比函数定义更复杂，因为你在编写编写Rust代码的Rust代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。</p> <p>宏和函数之间的另一个重要区别是，你必须在文件中调用宏之前定义宏或将其引入作用域，而不是函数，你可以在任何地方定义并在任何地方调用。</p> <h3 id="使用macro-rules-进行通用元编程的声明式宏"><a href="#使用macro-rules-进行通用元编程的声明式宏" class="header-anchor">#</a> 使用<code>macro_rules!</code>进行通用元编程的声明式宏</h3> <p>Rust中最广泛使用的宏形式是声明式宏。这些有时也被称为&quot;示例宏&quot;、&quot;<code>macro_rules!</code>宏&quot;或简称为&quot;宏&quot;。声明式宏的核心允许你编写类似于Rust <code>match</code>表达式的东西。正如第6章中讨论的，<code>match</code>表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也将值与与特定代码关联的模式进行比较：在这种情况下，值是传递给宏的字面Rust源代码；模式与该源代码的结构进行比较；与每个模式关联的代码在匹配时替换传递给宏的代码。这一切都在编译期间发生。</p> <p>要定义宏，你使用<code>macro_rules!</code>构造。让我们通过查看<code>vec!</code>宏是如何定义的来探索如何使用<code>macro_rules!</code>。第8章介绍了我们如何使用<code>vec!</code>宏创建具有特定值的新向量。例如，以下宏创建一个包含三个整数的新向量：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们也可以使用<code>vec!</code>宏创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们无法使用函数做同样的事情，因为我们不会提前知道值的数量或类型。</p> <p>示例20-35显示了<code>vec!</code>宏的稍微简化的定义。</p> <p>文件名：src/lib.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#[macro_export]</span>
<span class="token macro property">macro_rules!</span> vec <span class="token punctuation">{</span>
    <span class="token punctuation">(</span> $<span class="token punctuation">(</span> <span class="token variable">$x</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span> <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">let</span> <span class="token keyword">mut</span> temp_vec <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            $<span class="token punctuation">(</span>
                temp_vec<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">)</span><span class="token operator">*</span>
            temp_vec
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-35：<code>vec!</code>宏定义的简化版本</p> <blockquote><p>注意：标准库中<code>vec!</code>宏的实际定义包括预先分配正确内存量的代码。该代码是一个优化，我们在这里不包括它，以使示例更简单。</p></blockquote> <p><code>#[macro_export]</code>注解表示每当定义宏的<code>crate</code>被引入作用域时，这个宏就应该可用。如果没有这个注解，宏就不能被引入作用域。</p> <p>然后我们用<code>macro_rules!</code>和我们正在定义的宏的名称（不带感叹号）开始宏定义。在这种情况下，名称<code>vec</code>后跟花括号，表示宏定义的主体。</p> <p><code>vec!</code>主体中的结构类似于<code>match</code>表达式的结构。这里我们有一个带有模式<code>( $( $x:expr ),* )</code>的分支，后跟<code>=&gt;</code>和与此模式关联的代码块。如果模式匹配，将发出关联的代码块。鉴于这是此宏中的唯一模式，只有一种有效的匹配方式；任何其他模式都会导致错误。更复杂的宏将有多个分支。</p> <p>宏定义中的有效模式语法与第19章中涵盖的模式语法不同，因为宏模式是与Rust代码结构而不是值匹配的。让我们逐步了解示例20-29中的模式片段的含义；有关完整的宏模式语法，请参阅<a href="https://doc.rust-lang.org/reference/macros-by-example.html" target="_blank" rel="noopener noreferrer">Rust参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>首先，我们使用一组圆括号来包含整个模式。我们使用美元符号（<code>$</code>）在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号明确表示这是一个宏变量，而不是常规的Rust变量。接下来是一组圆括号，用于捕获在圆括号内匹配模式的值，以便在替换代码中使用。在<code>$()</code>内是<code>$x:expr</code>，它匹配任何Rust表达式并给表达式命名<code>$x</code>。</p> <p><code>$()</code>后面的逗号表示字面逗号分隔符字符必须出现在与<code>$()</code>内代码匹配的代码的每个实例之间。<code>*</code>指定模式匹配零个或多个前面的内容。</p> <p>当我们用<code>vec![1, 2, 3];</code>调用这个宏时，<code>$x</code>模式与三个表达式<code>1</code>、<code>2</code>和<code>3</code>匹配三次。</p> <p>现在让我们看看与此分支关联的代码主体中的模式：<code>$()*</code>内的<code>temp_vec.push()</code>为模式中与<code>$()</code>匹配的每个部分生成，零次或多次，取决于模式匹配的次数。<code>$x</code>被替换为每个匹配的表达式。当我们用<code>vec![1, 2, 3];</code>调用这个宏时，替换此宏调用生成的代码将是以下内容：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> temp_vec <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp_vec<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp_vec<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp_vec<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp_vec
<span class="token punctuation">}</span>
</code></pre></div><p>我们已经定义了一个宏，它可以接受任意数量的任意类型的参数，并可以生成代码来创建包含指定元素的向量。</p> <p>要了解更多关于如何编写宏的信息，请查阅在线文档或其他资源，例如Daniel Keep开始并由Lukas Wirth继续的<a href="https://veykril.github.io/tlborm/" target="_blank" rel="noopener noreferrer">&quot;Rust宏小册子&quot;<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="用于从属性生成代码的过程宏"><a href="#用于从属性生成代码的过程宏" class="header-anchor">#</a> 用于从属性生成代码的过程宏</h3> <p>宏的第二种形式是过程宏，它更像函数（并且是一种过程类型）。过程宏接受一些代码作为输入，对该代码进行操作，并产生一些代码作为输出，而不是像声明式宏那样与模式匹配并用其他代码替换代码。三种过程宏是自定义<code>derive</code>、类似属性和类似函数，它们都以类似的方式工作。</p> <p>创建过程宏时，定义必须驻留在具有特殊<code>crate</code>类型的自己的<code>crate</code>中。这是出于复杂的技术原因，我们希望在未来消除。在示例20-36中，我们展示了如何定义过程宏，其中<code>some_attribute</code>是使用特定宏变体的占位符。</p> <p>文件名：src/lib.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> proc_macro<span class="token punctuation">;</span>

<span class="token attribute attr-name">#[some_attribute]</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">some_name</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">TokenStream</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-36：定义过程宏的示例</p> <p>定义过程宏的函数接受<code>TokenStream</code>作为输入并产生<code>TokenStream</code>作为输出。<code>TokenStream</code>类型由Rust附带的<code>proc_macro</code> crate定义，表示<code>token</code>序列。这是宏的核心：宏操作的源代码构成输入<code>TokenStream</code>，宏产生的代码是输出<code>TokenStream</code>。该函数还有一个附加的属性，指定我们正在创建哪种过程宏。我们可以在同一个<code>crate</code>中拥有多种过程宏。</p> <p>让我们看看不同种类的过程宏。我们将从自定义<code>derive</code>宏开始，然后解释使其他形式不同的小差异。</p> <h3 id="如何编写自定义derive宏"><a href="#如何编写自定义derive宏" class="header-anchor">#</a> 如何编写自定义<code>derive</code>宏</h3> <p>让我们创建一个名为<code>hello_macro</code>的<code>crate</code>，它定义一个名为<code>HelloMacro</code>的<code>trait</code>，其中有一个名为<code>hello_macro</code>的关联函数。我们将提供一个过程宏，而不是让我们的用户为每种类型实现<code>HelloMacro</code> trait，这样用户可以用<code>#[derive(HelloMacro)]</code>注解他们的类型以获得<code>hello_macro</code>函数的默认实现。默认实现将打印<code>Hello, Macro! My name is TypeName!</code>，其中<code>TypeName</code>是定义此<code>trait</code>的类型的名称。换句话说，我们将编写一个<code>crate</code>，使另一个程序员能够使用我们的<code>crate</code>编写如示例20-37的代码。</p> <p>文件名：src/main.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">hello_macro<span class="token punctuation">::</span></span><span class="token class-name">HelloMacro</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">hello_macro_derive<span class="token punctuation">::</span></span><span class="token class-name">HelloMacro</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[derive(HelloMacro)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Pancakes</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Pancakes</span><span class="token punctuation">::</span><span class="token function">hello_macro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-37：我们的<code>crate</code>用户在使用我们的过程宏时能够编写的代码</p> <p>完成后，此代码将打印<code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库<code>crate</code>，如下所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo new hello_macro <span class="token operator">-</span><span class="token operator">-</span>lib
</code></pre></div><p>接下来，我们将定义<code>HelloMacro</code> trait及其关联函数：</p> <p>文件名：src/lib.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">HelloMacro</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">hello_macro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-38：我们将与<code>derive</code>宏一起使用的简单<code>trait</code></p> <p>我们有一个<code>trait</code>及其函数。此时，我们的<code>crate</code>用户可以实现<code>trait</code>以实现所需的功能，如示例20-39所示。</p> <p>文件名：src/main.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">hello_macro<span class="token punctuation">::</span></span><span class="token class-name">HelloMacro</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">Pancakes</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">HelloMacro</span> <span class="token keyword">for</span> <span class="token class-name">Pancakes</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">hello_macro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, Macro! My name is Pancakes!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Pancakes</span><span class="token punctuation">::</span><span class="token function">hello_macro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-39：如果用户编写<code>HelloMacro</code> trait的手动实现，它会是什么样子</p> <p>但是，他们需要为每个要与<code>hello_macro</code>一起使用的类型编写实现块；我们希望让他们免于做这项工作。</p> <p>此外，我们还不能为<code>hello_macro</code>函数提供默认实现来打印实现<code>trait</code>的类型的名称：Rust没有反射功能，因此它无法在运行时查找类型的名称。我们需要一个宏来在编译时生成代码。</p> <p>下一步是定义过程宏。在撰写本文时，过程宏需要在自己的<code>crate</code>中。最终，这个限制可能会被取消。构造<code>crate</code>和宏<code>crate</code>的约定如下：对于名为<code>foo</code>的<code>crate</code>，自定义<code>derive</code>过程宏<code>crate</code>称为<code>foo_derive</code>。让我们在我们的<code>hello_macro</code>项目中启动一个名为<code>hello_macro_derive</code>的新<code>crate</code>：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>$ cargo new hello_macro_derive <span class="token operator">-</span><span class="token operator">-</span>lib
</code></pre></div><p>我们的两个<code>crate</code>紧密相关，因此我们在<code>hello_macro</code> crate的目录中创建过程宏<code>crate</code>。如果我们更改<code>hello_macro</code>中的<code>trait</code>定义，我们也必须更改<code>hello_macro_derive</code>中过程宏的实现。这两个<code>crate</code>需要单独发布，使用这些<code>crate</code>的程序员需要将两者都添加为依赖项并将它们都引入作用域。我们可以让<code>hello_macro</code> crate使用<code>hello_macro_derive</code>作为依赖项并重新导出过程宏代码。然而，我们构造项目的方式使程序员即使不想要<code>derive</code>功能也可以使用<code>hello_macro</code>。</p> <p>我们需要将<code>hello_macro_derive</code> crate声明为过程宏<code>crate</code>。我们还需要来自<code>syn</code>和<code>quote</code> crate的功能，正如你稍后会看到的，所以我们需要将它们添加为依赖项。将以下内容添加到<code>hello_macro_derive</code>的Cargo.toml文件中：</p> <p>文件名：hello_macro_derive/Cargo.toml：</p> <div class="language-toml extra-class"><pre class="language-toml"><code><span class="token punctuation">[</span><span class="token table class-name">lib</span><span class="token punctuation">]</span>
<span class="token key property">proc-macro</span> <span class="token punctuation">=</span> <span class="token boolean">true</span>

<span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span>
<span class="token key property">syn</span> <span class="token punctuation">=</span> <span class="token string">&quot;2.0&quot;</span>
<span class="token key property">quote</span> <span class="token punctuation">=</span> <span class="token string">&quot;1.0&quot;</span>
</code></pre></div><p>要开始定义过程宏，请将示例20-40中的代码放入<code>hello_macro_derive</code> crate的src/lib.rs文件中。请注意，在我们添加<code>impl_hello_macro</code>函数的定义之前，此代码不会编译。</p> <p>文件名：hello_macro_derive/src/lib.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">proc_macro<span class="token punctuation">::</span></span><span class="token class-name">TokenStream</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">quote<span class="token punctuation">::</span></span>quote<span class="token punctuation">;</span>

<span class="token attribute attr-name">#[proc_macro_derive(HelloMacro)]</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">hello_macro_derive</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">TokenStream</span> <span class="token punctuation">{</span>
    <span class="token comment">// Construct a representation of Rust code as a syntax tree</span>
    <span class="token comment">// that we can manipulate.</span>
    <span class="token keyword">let</span> ast <span class="token operator">=</span> <span class="token namespace">syn<span class="token punctuation">::</span></span><span class="token function">parse</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Build the trait implementation.</span>
    <span class="token function">impl_hello_macro</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ast<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-40：大多数过程宏<code>crate</code>为了处理Rust代码而需要的代码</p> <p>注意我们已经将代码分成了<code>hello_macro_derive</code>函数（负责解析<code>TokenStream</code>）和<code>impl_hello_macro</code>函数（负责转换语法树）：这使得编写过程宏更方便。外部函数（在这种情况下是<code>hello_macro_derive</code>）中的代码对于你看到或创建的几乎每个过程宏<code>crate</code>都是相同的。你在内部函数（在这种情况下是<code>impl_hello_macro</code>）主体中指定的代码将根据你的过程宏的目的而有所不同。</p> <p>我们已经引入了三个新的<code>crate</code>：<code>proc_macro</code>、<a href="https://crates.io/crates/syn" target="_blank" rel="noopener noreferrer">syn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://crates.io/crates/quote" target="_blank" rel="noopener noreferrer">quote<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。<code>proc_macro</code> crate随Rust一起提供，所以我们不需要将其添加到Cargo.toml中的依赖项中。<code>proc_macro</code> crate是编译器的API，允许我们从我们的代码中读取和操作Rust代码。</p> <p><code>syn</code> crate将Rust代码从字符串解析为我们可以执行操作的数据结构。<code>quote</code> crate将<code>syn</code>数据结构转换回Rust代码。这些<code>crate</code>使解析我们可能想要处理的任何类型的Rust代码变得更加简单：为Rust代码编写完整的解析器不是一项简单的任务。</p> <p>当库用户在类型上指定<code>#[derive(HelloMacro)]</code>时，将调用<code>hello_macro_derive</code>函数。这是可能的，因为我们在这里用<code>proc_macro_derive</code>注解了<code>hello_macro_derive</code>函数并指定了名称<code>HelloMacro</code>，它与我们的<code>trait</code>名称匹配；这是大多数过程宏遵循的约定。</p> <p><code>hello_macro_derive</code>函数首先将输入从<code>TokenStream</code>转换为我们可以解释和执行操作的数据结构。这就是<code>syn</code>发挥作用的地方。<code>syn</code>中的<code>parse</code>函数接受<code>TokenStream</code>并返回表示解析的Rust代码的<code>DeriveInput</code>结构。示例20-41显示了我们从解析<code>struct Pancakes;</code>字符串中获得的<code>DeriveInput</code>结构的相关部分。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token class-name">DeriveInput</span> <span class="token punctuation">{</span>
    <span class="token comment">// --snip--</span>

    ident<span class="token punctuation">:</span> <span class="token class-name">Ident</span> <span class="token punctuation">{</span>
        ident<span class="token punctuation">:</span> <span class="token string">&quot;Pancakes&quot;</span><span class="token punctuation">,</span>
        span<span class="token punctuation">:</span> #<span class="token number">0</span> <span class="token function">bytes</span><span class="token punctuation">(</span><span class="token number">95</span><span class="token punctuation">..</span><span class="token number">103</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token class-name">Struct</span><span class="token punctuation">(</span>
        <span class="token class-name">DataStruct</span> <span class="token punctuation">{</span>
            struct_token<span class="token punctuation">:</span> <span class="token class-name">Struct</span><span class="token punctuation">,</span>
            fields<span class="token punctuation">:</span> <span class="token class-name">Unit</span><span class="token punctuation">,</span>
            semi_token<span class="token punctuation">:</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>
                <span class="token class-name">Semi</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-41：当解析示例20-37中具有宏属性的代码时，我们获得的<code>DeriveInput</code>实例</p> <p>此结构的字段显示我们解析的Rust代码是一个单元结构，其<code>ident</code>（标识符，表示名称）为<code>Pancakes</code>。此结构上有更多字段用于描述各种Rust代码；查看<a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html" target="_blank" rel="noopener noreferrer"><code>DeriveInput</code>的syn文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>以获取更多信息。</p> <p>很快我们将定义<code>impl_hello_macro</code>函数，这是我们构建要包含的新Rust代码的地方。但在我们这样做之前，请注意我们的<code>derive</code>宏的输出也是<code>TokenStream</code>。返回的<code>TokenStream</code>被添加到我们的<code>crate</code>用户编写的代码中，因此当他们编译他们的<code>crate</code>时，他们将获得我们在修改的<code>TokenStream</code>中提供的额外功能。</p> <p>你可能已经注意到，如果对<code>syn::parse</code>函数的调用失败，我们调用<code>unwrap</code>来导致<code>hello_macro_derive</code>函数恐慌。我们的过程宏有必要在错误时恐慌，因为<code>proc_macro_derive</code>函数必须返回<code>TokenStream</code>而不是<code>Result</code>以符合过程宏API。我们通过使用<code>unwrap</code>简化了此示例；在生产代码中，你应该通过使用<code>panic!</code>或<code>expect</code>提供更具体的错误消息，说明出了什么问题。</p> <p>现在我们有了将带注解的Rust代码从<code>TokenStream</code>转换为<code>DeriveInput</code>实例的代码，让我们生成在带注解类型上实现<code>HelloMacro</code> trait的代码，如示例20-42所示。</p> <p>文件名：hello_macro_derive/src/lib.rs：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">proc_macro<span class="token punctuation">::</span></span><span class="token class-name">TokenStream</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">quote<span class="token punctuation">::</span></span>quote<span class="token punctuation">;</span>

<span class="token attribute attr-name">#[proc_macro_derive(HelloMacro)]</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">hello_macro_derive</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">TokenStream</span> <span class="token punctuation">{</span>
    <span class="token comment">// Construct a representation of Rust code as a syntax tree</span>
    <span class="token comment">// that we can manipulate</span>
    <span class="token keyword">let</span> ast <span class="token operator">=</span> <span class="token namespace">syn<span class="token punctuation">::</span></span><span class="token function">parse</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Build the trait implementation</span>
    <span class="token function">impl_hello_macro</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ast<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">impl_hello_macro</span><span class="token punctuation">(</span>ast<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token namespace">syn<span class="token punctuation">::</span></span><span class="token class-name">DeriveInput</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">TokenStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token operator">&amp;</span>ast<span class="token punctuation">.</span>ident<span class="token punctuation">;</span>
    <span class="token keyword">let</span> generated <span class="token operator">=</span> <span class="token macro property">quote!</span> <span class="token punctuation">{</span>
        <span class="token keyword">impl</span> <span class="token class-name">HelloMacro</span> <span class="token keyword">for</span> #name <span class="token punctuation">{</span>
            <span class="token keyword">fn</span> <span class="token function-definition function">hello_macro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, Macro! My name is {}!&quot;</span><span class="token punctuation">,</span> <span class="token macro property">stringify!</span><span class="token punctuation">(</span>#name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    generated<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例20-42：使用解析的Rust代码实现<code>HelloMacro</code> trait</p> <p>我们使用<code>ast.ident</code>获得包含带注解类型名称（标识符）的<code>Ident</code>结构实例。示例20-33中的结构显示，当我们在示例20-31中的代码上运行<code>impl_hello_macro</code>函数时，我们获得的<code>ident</code>将具有值为<code>&quot;Pancakes&quot;</code>的<code>ident</code>字段。因此，示例20-34中的<code>name</code>变量将包含一个<code>Ident</code>结构实例，当打印时，将是字符串<code>&quot;Pancakes&quot;</code>，即示例20-37中结构的名称。</p> <p><code>quote!</code>宏让我们定义我们想要返回的Rust代码。编译器期望的东西与<code>quote!</code>宏执行的直接结果不同，因此我们需要将其转换为<code>TokenStream</code>。我们通过调用<code>into</code>方法来做到这一点，该方法消耗这个中间表示并返回所需的<code>TokenStream</code>类型的值。</p> <p><code>quote!</code>宏还提供了一些非常酷的模板机制：我们可以输入<code>#name</code>，<code>quote!</code>会用变量<code>name</code>中的值替换它。你甚至可以进行一些类似于常规宏工作方式的重复。查看<a href="https://docs.rs/quote" target="_blank" rel="noopener noreferrer"><code>quote</code> crate的文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>以获得全面的介绍。</p> <p>我们希望我们的过程宏为用户注解的类型生成我们的<code>HelloMacro</code> trait的实现，我们可以通过使用<code>#name</code>获得该类型。<code>trait</code>实现有一个函数<code>hello_macro</code>，其主体包含我们想要提供的功能：打印<code>Hello, Macro! My name is</code>然后是带注解类型的名称。</p> <p>这里使用的<code>stringify!</code>宏内置于Rust中。它接受一个Rust表达式，如<code>1 + 2</code>，并在编译时将表达式转换为字符串字面量，如<code>&quot;1 + 2&quot;</code>。这与<code>format!</code>或<code>println!</code>宏不同，后者计算表达式然后将结果转换为<code>String</code>。有可能<code>#name</code>输入可能是要按字面打印的表达式，所以我们使用<code>stringify!</code>。使用<code>stringify!</code>还通过在编译时将<code>#name</code>转换为字符串字面量来节省分配。</p> <p>此时，<code>cargo build</code>应该在<code>hello_macro</code>和<code>hello_macro_derive</code>中都成功完成。让我们将这些<code>crate</code>连接到示例20-31中的代码，看看过程宏的运行情况！使用<code>cargo new pancakes</code>在你的项目目录中创建一个新的二进制项目。我们需要将<code>hello_macro</code>和<code>hello_macro_derive</code>作为依赖项添加到<code>pancakes</code> crate的Cargo.toml中。如果你将你的<code>hello_macro</code>和<code>hello_macro_derive</code>版本发布到crates.io，它们将是常规依赖项；如果没有，你可以将它们指定为路径依赖项，如下所示：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>hello_macro <span class="token operator">=</span> <span class="token punctuation">{</span> path <span class="token operator">=</span> <span class="token string">&quot;../hello_macro&quot;</span> <span class="token punctuation">}</span>
hello_macro_derive <span class="token operator">=</span> <span class="token punctuation">{</span> path <span class="token operator">=</span> <span class="token string">&quot;../hello_macro/hello_macro_derive&quot;</span> <span class="token punctuation">}</span>
</code></pre></div><p>将示例20-37中的代码放入src/main.rs，然后运行<code>cargo run</code>：它应该打印<code>Hello, Macro! My name is Pancakes!</code>来自过程宏的<code>HelloMacro</code> trait的实现被包含在内，而<code>pancakes</code> crate不需要实现它；<code>#[derive(HelloMacro)]</code>添加了<code>trait</code>实现。</p> <p>接下来，让我们探索其他类型的过程宏与自定义<code>derive</code>宏的不同之处。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/advanced-features/advanced-functions-and-closures.html" class="prev">
        高级函数和闭包
      </a></span> <span class="next"><a href="/rust-doc/doc/final-project/single-threaded.html">
        构建单线程Web服务器
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.f0d374f6.js" defer></script><script src="/rust-doc/assets/js/2.f80c1e3f.js" defer></script><script src="/rust-doc/assets/js/1.fd67daac.js" defer></script><script src="/rust-doc/assets/js/41.c051920d.js" defer></script>
  </body>
</html>
