## 数据类型

Rust 中的每个值都属于特定的数据类型，这告诉 Rust 指定了哪种数据，以便它知道如何处理这些数据。我们将研究两种数据类型子集：标量和复合。

请记住，Rust 是一种静态类型语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值及其使用方式推断出我们想要使用的类型。在可能存在多种类型的情况下，例如当我们在第 2 章的“[将猜测数字与秘密数字进行比较](./guess-game.md#将猜测数字与秘密数字进行比较)”部分中使用 `parse` 将字符串转换为数字类型时，我们必须添加类型注释，如下所示：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果我们不添加上述代码中所示的 `:u32` 类型注释，Rust 将显示以下错误，这意味着编译器需要我们提供更多信息来知道我们要使用哪种类型：

```rust
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `<_ as FromStr>::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
```

你将看到其他数据类型的不同类型注释。

### 标量类型

标量类型表示单个值。Rust 有四种主要标量类型：整数、浮点数、布尔值和字符串。你可能在其他编程语言中见过这些类型。让我们来看看它们在 Rust 中的工作原理。

#### 整数类型

整数是没有小数部分的数字。我们在第 2 章中使用了一种整数类型，即 u32 类型。此类型声明表示它所关联的值应为无符号整数（有符号整数类型以 i 而不是 u 开头），占用 32 位空间。表 3-1 显示了 Rust 中的内置整数类型。我们可以使用这些变量中的任何一种来声明整数值的类型。

表 3-1: Rust 中的整数类型

| 长度       | 有符号 | 无符号 |
| ---------- | ------ | ------ |
| 8-bit      | i8     | u8     |
| 16-bit     | i16    | u16    |
| 32-bit     | i32    | u32    |
| 64-bit     | i64    | u64    |
| 128-bit    | i128   | u128   |
| arch(架构) | isize  | usize  |

每个变量可以是有符号的，也可以是无符号的，并且具有明确的大小。有符号和无符号指的是数字是否可能为负数，换句话说，数字是否需要带有符号（有符号）或者它是否永远都是正数，因此可以不用符号表示（无符号）。这就像在纸上写数字：当符号很重要时，数字会显示加号或减号；但是，当可以安全地假设数字为正数时，它不会显示符号。有符号数字使用[二进制补码表示法](https://en.wikipedia.org/wiki/Two%27s_complement)存储。

每个有符号变量可以存储从 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1（含）的数字，其中 n 是变量使用的位数。因此，i8 可以存储从 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1（等于 -128 到 127）的数字。无符号变量可以存储从 0 到 2<sup>n</sup> - 1 的数字，因此 u8 可以存储从 0 到 2<sup>8</sup> - 1（等于 0 到 255）的数字。

此外，isize 和 usize 类型取决于程序所运行的计算机的体系结构，在表 3-1 中表示为“arch(可以理解是架构的意思)一行”：如果使用 64 位体系结构，则为 64 位；如果使用 32 位体系结构，则为 32 位。

你可以采用表 3-2 中所示的任何一种形式来编写整数文字。请注意，可以为多种数字类型的数字文字允许使用类型后缀（例如`57u8`）来指定类型。数字文字还可以使用 `_` 作为视觉分隔符，使数字更易于阅读，例如 `1_000`，其值与你指定 1000 时的值相同。

表 3-2: rust 中的整数文字

| 数值文字       | 示例        |
| -------------- | ----------- |
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

那么你如何知道要使用哪种类型的整数？如果你不确定，Rust 的默认值通常是不错的起点：整数类型默认为 i32。你使用 isize 或 usize 的主要情况是索引某种集合时。

##### 整数溢出

假设你有一个 u8 类型的变量，它可以保存 0 到 255 之间的值。如果你尝试将变量更改为该范围之外的值（例如 256），则会发生整数溢出，这可能导致两种行为之一。在调试模式下编译时，Rust 会检查整数溢出，如果发生此行为，则会导致程序在运行时崩溃。Rust 在程序因错误退出时使用术语“崩溃”；我们将在第 9 章的“无法恢复的崩溃错误！”部分更深入地讨论崩溃。

在使用 `--release` 标志在发布模式下编译时，Rust 不会检查导致崩溃的整数溢出。相反，如果发生溢出，Rust 会执行二进制补码包装。简而言之，大于类型可以保存的最大值的值“包装”到类型可以保存的最小值。对于 u8，值 256 变为 0，值 257 变为 1，依此类推。程序不会崩溃，但变量的值可能不是你预期的值。依赖整数溢出的包装行为被视为错误。

要明确处理溢出的可能性，你可以使用标准库为原始数字类型提供的这些方法系列：

- 使用 `wrapping_*` 方法（例如`wrapping_add`）在所有模式下包装。
- 如果使用 `checked_*` 方法发生溢出，则返回 None 值。
- 返回 `overflowing_*` 方法的值和一个布尔值，指示是否发生溢出。
- 使用 `saturating_*` 方法在值的最小值或最大值处饱和。

#### 浮点类型