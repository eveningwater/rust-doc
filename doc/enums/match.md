## match 控制流构造

Rust 有一个非常强大的控制流构造，称为 match，它允许你将一个值与一系列模式进行比较，然后根据模式匹配执行代码。模式可以由文字值、变量名、通配符和许多其他内容组成；第 18 章介绍了所有不同类型的模式及其作用。match 的强大之处在于模式的表达能力以及编译器确认所有可能的情况都得到处理的事实。

可以将匹配表达式想象成一台硬币分类机：硬币沿着轨道滑下，轨道上有各种大小的孔，每枚硬币都会从它遇到的第一个适合它的孔中掉落。同样，值也会在匹配中经历每个模式，在值“适合”的第一个模式中，该值会落入关联的代码块中，以便在执行期间使用。

说到硬币，让我们用 match 来举例！我们可以编写一个函数，接受一个未知的美国硬币，并以与计数机类似的方式确定它是哪种硬币并返回其价值（以美分为单位），如示例 6-3 所示。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

示例 6-3：一个枚举和一个以枚举的变体作为模式的匹配表达式

让我们拆分理解一下 value_in_cents 函数中的 match。首先，我们列出 match 关键字，后面跟着一个表达式，在本例中是值 coin。这看起来与 if 中使用的条件表达式非常相似，但有一个很大的区别：对于 if，条件需要计算为布尔值，但在这里它可以是任何类型。本例中的硬币类型是我们在第一行定义的 Coin 枚举。

接下来是 match 分支。分支由两部分组成：模式和一些代码。这里的第一个分支有一个模式，其值为 Coin::Penny，然后是 => 运算符，它将模式和要运行的代码分开。本例中的代码只是值 1。每个分支与下一个分支之间用逗号分隔。

当 match 表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果模式与值匹配，则执行与该模式关联的代码。如果该模式与值不匹配，则继续执行下一个分支，就像硬币分类机一样。我们可以根据需要拥有任意数量的分支：在示例 6-3 中，我们的 match 有四个分支。

与每个分支相关的代码是一个表达式，匹配分支中表达式的结果值是整个匹配表达式返回的值。

如果匹配分支代码较短，我们通常不使用花括号，如示例 6-3 中所示，其中每个分支仅返回一个值。如果要在匹配分支中运行多行代码，则必须使用花括号，分支后面的逗号是可选的。例如，以下代码每次使用 `Coin::Penny` 调用该方法时都会打印`“Lucky penny!”`，但仍然返回块的最后一个值 1：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 与值绑定的模式

匹配分支的另一个有用功能是它们可以绑定到与模式匹配的值的部分。这就是我们从枚举变量中提取值的方法。

举个例子，让我们修改一个枚举变量，使其内部保存数据。从 1999 年到 2008 年，美国铸造了 25 美分硬币，一面有 50 个州的图案。其他硬币都没有州图案，所以只有 25 美分硬币有这个额外的值。我们可以将这些信息添加到枚举中，方法是将 Quarter 变量更改为包含存储在其中的 UsState 值，我们在示例 6-4 中已经这样做了。

```rust
#[derive(Debug)] // 所以我们可以在一分钟内检查状态
enum UsState {
    Alabama,
    Alaska,
    // 省略
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {}
```

示例 6-4：Coin 枚举，其中 Quarter 变量还包含 UsState 值