<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>定义一个枚举 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.c73659be.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.9d368bc8.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.8e1d7368.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.e0f7c23c.js" as="script"><link rel="preload" href="/rust-doc/assets/js/44.d63af212.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.10e9729b.js"><link rel="prefetch" href="/rust-doc/assets/js/11.eec788fd.js"><link rel="prefetch" href="/rust-doc/assets/js/12.f50da0fd.js"><link rel="prefetch" href="/rust-doc/assets/js/13.c2fab92d.js"><link rel="prefetch" href="/rust-doc/assets/js/14.35ec648b.js"><link rel="prefetch" href="/rust-doc/assets/js/15.62d65329.js"><link rel="prefetch" href="/rust-doc/assets/js/16.6a15cea6.js"><link rel="prefetch" href="/rust-doc/assets/js/17.c13d4c43.js"><link rel="prefetch" href="/rust-doc/assets/js/18.dfa72d75.js"><link rel="prefetch" href="/rust-doc/assets/js/19.87b04eff.js"><link rel="prefetch" href="/rust-doc/assets/js/20.121157cc.js"><link rel="prefetch" href="/rust-doc/assets/js/21.8b6468c9.js"><link rel="prefetch" href="/rust-doc/assets/js/22.016cd093.js"><link rel="prefetch" href="/rust-doc/assets/js/23.50eec74b.js"><link rel="prefetch" href="/rust-doc/assets/js/24.c4bc3db9.js"><link rel="prefetch" href="/rust-doc/assets/js/25.7daee9e8.js"><link rel="prefetch" href="/rust-doc/assets/js/26.1d23c4dd.js"><link rel="prefetch" href="/rust-doc/assets/js/27.f4cf98e6.js"><link rel="prefetch" href="/rust-doc/assets/js/28.ec59cae2.js"><link rel="prefetch" href="/rust-doc/assets/js/29.3727251b.js"><link rel="prefetch" href="/rust-doc/assets/js/3.f0d80f91.js"><link rel="prefetch" href="/rust-doc/assets/js/30.43813a37.js"><link rel="prefetch" href="/rust-doc/assets/js/31.40c05473.js"><link rel="prefetch" href="/rust-doc/assets/js/32.b55084bb.js"><link rel="prefetch" href="/rust-doc/assets/js/33.9aa0d715.js"><link rel="prefetch" href="/rust-doc/assets/js/34.2ed8dfd5.js"><link rel="prefetch" href="/rust-doc/assets/js/35.e172279e.js"><link rel="prefetch" href="/rust-doc/assets/js/36.67efc958.js"><link rel="prefetch" href="/rust-doc/assets/js/37.3f8d6e10.js"><link rel="prefetch" href="/rust-doc/assets/js/38.eb38ec9b.js"><link rel="prefetch" href="/rust-doc/assets/js/39.e221e4a6.js"><link rel="prefetch" href="/rust-doc/assets/js/4.572bd15d.js"><link rel="prefetch" href="/rust-doc/assets/js/40.4c3648f2.js"><link rel="prefetch" href="/rust-doc/assets/js/41.778b4018.js"><link rel="prefetch" href="/rust-doc/assets/js/42.72febd8f.js"><link rel="prefetch" href="/rust-doc/assets/js/43.2329871d.js"><link rel="prefetch" href="/rust-doc/assets/js/45.e88ef1a8.js"><link rel="prefetch" href="/rust-doc/assets/js/46.fa453842.js"><link rel="prefetch" href="/rust-doc/assets/js/47.cd7ce34c.js"><link rel="prefetch" href="/rust-doc/assets/js/48.dfec63a7.js"><link rel="prefetch" href="/rust-doc/assets/js/49.fd51e2b5.js"><link rel="prefetch" href="/rust-doc/assets/js/5.ae005ef1.js"><link rel="prefetch" href="/rust-doc/assets/js/50.4a9118fe.js"><link rel="prefetch" href="/rust-doc/assets/js/51.e02bef30.js"><link rel="prefetch" href="/rust-doc/assets/js/52.a6bb2ffb.js"><link rel="prefetch" href="/rust-doc/assets/js/6.62658830.js"><link rel="prefetch" href="/rust-doc/assets/js/7.44029ed2.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.3e3e72ff.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.c73659be.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable"><span>认识所有权</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable"><span>使用结构体来构造相关数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable open"><span>枚举</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/enums/defining-an-enum.html" aria-current="page" class="active sidebar-link">定义一个枚举</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/enums/defining-an-enum.html#定义一个枚举" class="sidebar-link">定义一个枚举</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="定义一个枚举"><a href="#定义一个枚举" class="header-anchor">#</a> 定义一个枚举</h2> <p>结构体为你提供了一种将相关字段和数据组合在一起的方法，例如具有width和height的 Rectangle，而枚举为你提供了一种表示某个值是一组可能值之一的方法。例如，我们可能想说 Rectangle 是一组可能形状之一，该集合还包括 Circle 和 Triangle。为此，Rust 允许我们将这些可能性编码为枚举。</p> <p>让我们看看我们可能想要在代码中表达的情况，看看为什么枚举在这种情况下比结构更有用、更合适。假设我们需要处理 IP 地址。目前，IP 地址使用两个主要标准：v4 和 v6。因为这些是我们的程序会遇到的唯一可能的 IP 地址，所以我们可以枚举所有可能的变量，这就是枚举名称的由来。</p> <p>任何 IP 地址都可以是v4 或v6地址，但不能同时是两者。IP 地址的这一特性使得枚举数据结构非常合适，因为枚举值只能是其变体之一。v4 和v6地址从根本上来说仍然是 IP 地址，因此当代码处理适用于任何类型的 IP 地址的情况时，应将它们视为同一类型。</p> <p>我们可以通过定义 IpAddrKind 枚举并列出 IP 地址可能的类型 V4 和 V6，在代码中表达这一概念。这些是枚举的变体：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddrKind</span> <span class="token punctuation">{</span>
    <span class="token constant">V4</span><span class="token punctuation">,</span>
    <span class="token constant">V6</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>IpAddrKind 现在是一种自定义数据类型，我们可以在代码的其他地方使用它。</p> <h3 id="枚举值"><a href="#枚举值" class="header-anchor">#</a> 枚举值</h3> <p>我们可以像这样创建 IpAddrKind 的两个变量的实例：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">let</span> four <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> six <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意，枚举的变量在其标识符下命名，我们使用双冒号将两者分开。这很有用，因为现在 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 这两个值都属于同一类型：<code>IpAddrKind</code>。然后，例如，我们可以定义一个接受任何 <code>IpAddrKind</code> 的函数：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">route</span><span class="token punctuation">(</span>ip_kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>我们可以用以下任一方式调用该函数：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token function">route</span><span class="token punctuation">(</span><span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">route</span><span class="token punctuation">(</span><span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用枚举还有更多优势。仔细考虑一下我们的 IP 地址类型，目前我们没有办法存储实际的 IP 地址数据；我们只知道它是什么类型。鉴于你刚刚在第 5 章中学习了结构体，你可能会想用结构体来解决这个问题，如示例 6-1 所示。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddrKind</span> <span class="token punctuation">{</span>
    <span class="token constant">V4</span><span class="token punctuation">,</span>
    <span class="token constant">V6</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">,</span>
    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;::1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>示例 6-1：使用结构体存储 IP 地址的数据和 IpAddrKind 变量</p> <p>这里，我们定义了一个结构体 IpAddr，它有两个字段：一个类型为 IpAddrKind（我们之前定义的枚举）的 kind 字段和一个类型为 String 的 address 字段。我们有两个此结构体的实例。第一个是 home，它的类型值为 <code>IpAddrKind::V4</code>，关联的地址数据为 <code>127.0.0.1</code>。第二个实例是 loopback。它的类型值为 IpAddrKind 的另一个变量 V6，关联的地址为 <code>::1</code>。我们使用结构体将类型和地址值捆绑在一起，因此现在变量与值相关联。</p> <p>但是，仅使用枚举来表示相同的概念更为简洁：我们可以将数据直接放入每个枚举变量中，而不是将枚举放在结构体中。IpAddr 枚举的这个新定义表明 V4 和 V6 变量都将具有关联的字符串值：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>
    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;::1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们直接将数据附加到枚举的每个变量，因此不需要额外的结构体。在这里，也更容易看到枚举如何工作的另一个细节：我们定义的每个枚举变量的名称也成为构造枚举实例的函数。也就是说，<code>IpAddr::V4()</code> 是一个函数调用，它接受一个 String 参数并返回一个 IpAddr 类型的实例。我们自动获得这个构造函数的定义，这是定义枚举的结果。</p> <p>使用枚举而不是结构还有另一个优势：每个变量可以具有不同类型和数量的关联数据。版本 4 IP 地址将始终具有四个数字组件，其值介于 0 到 255 之间。如果我们想将 V4 地址存储为四个 u8 值，但仍将 V6 地址表示为一个字符串值，则无法使用结构体。枚举可以轻松处理这种情况：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>
    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;::1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们已经展示了几种定义数据结构来存储版本 4 和版本 6 IP 地址的不同方法。然而，事实证明，想要存储 IP 地址并编码其类型是如此常见，以至于<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html" target="_blank" rel="noopener noreferrer">标准库有一个我们可以使用的定义<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>！让我们看看标准库如何定义 IpAddr：它具有我们定义和使用的确切枚举和变量，但它以两种不同结构的形式将地址数据嵌入到变量中，每个变量的定义不同：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv4Addr</span> <span class="token punctuation">{</span>
        <span class="token comment">// --snip--</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv6Addr</span> <span class="token punctuation">{</span>
        <span class="token comment">// --snip--</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>
        <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">Ipv4Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">Ipv6Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此代码说明，你可以将任何类型的数据放入枚举变量中：例如字符串、数字类型或结构。你甚至可以包含另一个枚举！此外，标准库类型通常不会比你可能想到的复杂得多。</p> <p>请注意，尽管标准库包含 IpAddr 的定义，但我们仍然可以创建和使用自己的定义而不会发生冲突，因为我们没有将标准库的定义纳入我们的作用域。我们将在第 7 章中进一步讨论如何将类型纳入作用域。</p> <p>让我们看一下示例 6-2 中的另一个枚举示例：这个示例的变量中嵌入了多种类型。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token class-name">Quit</span><span class="token punctuation">,</span>
    <span class="token class-name">Move</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 6-2：一个 Message 枚举，其每个变量都存储不同数量和类型的值</p> <p>此枚举有四种不同类型的变体：</p> <ul><li>Quit 根本没有与之关联的数据。</li> <li>Move 有命名字段，就像结构一样。</li> <li>Write 包含单个字符串。</li> <li>ChangeColor 包含三个 i32 值。</li></ul> <p>定义带有变量的枚举（如示例 6-2 中所示）类似于定义不同类型的结构体定义，只是枚举不使用 struct 关键字，并且所有变体都归入 Message 类型。以下结构体可以保存前面枚举变量保存的相同数据：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">QuitMessage</span><span class="token punctuation">;</span> <span class="token comment">// unit struct</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">MoveMessage</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">WriteMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tuple struct</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">ChangeColorMessage</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tuple struct</span>
</code></pre></div><p>但是如果我们使用不同的结构体，每个结构体都有自己的类型，我们就无法像示例 6-2 中定义的 Message 枚举那样轻松地定义一个函数来接收任何这些类型的消息，因为它只有一种类型。</p> <p>枚举和结构之间还有一个相似之处：就像我们能够使用 impl 在结构上定义方法一样，我们也能够在枚举上定义方法。以下是我们可以在我们的 Message 枚举上定义名为 call 的方法：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// method body would be defined here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>方法主体将使用 self 来获取我们调用该方法时的值。在此示例中，我们创建了一个变量 m，其值为 <code>Message::Write(String::from(&quot;hello&quot;))</code>，当 m.call() 运行时，self 将会位于 call 方法主体中。</p> <p>让我们看一下标准库中另一个非常常见且有用的枚举：Option。</p> <h3 id="option-enum-及其相对于-null-值的优势"><a href="#option-enum-及其相对于-null-值的优势" class="header-anchor">#</a> Option Enum 及其相对于 Null 值的优势</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/structs/method-syntax.html" class="prev">
        方法语法
      </a></span> <span class="next"><a href="/rust-doc/doc/appendix/appendix-a.html">
        附录A: 关键字
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.9d368bc8.js" defer></script><script src="/rust-doc/assets/js/2.8e1d7368.js" defer></script><script src="/rust-doc/assets/js/1.e0f7c23c.js" defer></script><script src="/rust-doc/assets/js/44.d63af212.js" defer></script>
  </body>
</html>
