## 重构以提高模块化和错误处理

为了改进我们的程序，我们将解决四个与程序结构和潜在错误处理相关的问题。首先，我们的`main`函数现在执行两项任务：解析参数和读取文件。随着程序的增长，`main`函数处理的任务数量将会增加。当一个函数获得更多责任时，它变得更难以推理，更难以测试，更难以在不破坏其某一部分的情况下进行更改。最好将功能分离，使每个函数只负责一项任务。

这个问题也与第二个问题相关：尽管`query`和`file_path`是我们程序的配置变量，但像`contents`这样的变量用于执行程序的逻辑。`main`函数越长，我们需要引入作用域的变量就越多；作用域中的变量越多，就越难跟踪每个变量的用途。最好将配置变量分组到一个结构中，以明确它们的目的。

第三个问题是，当读取文件失败时，我们使用了`expect`来打印错误消息，但错误消息只是打印`Should have been able to read the file`（应该能够读取文件）。读取文件可能因多种原因而失败：例如，文件可能丢失，或者我们可能没有权限打开它。目前，无论情况如何，我们都会为所有情况打印相同的错误消息，这不会给用户提供任何信息！

第四，我们使用`expect`来处理错误，如果用户在运行程序时没有指定足够的参数，他们将从 Rust 获得一个`index out of bounds`（索引超出范围）错误，这并不能清楚地解释问题。最好将所有错误处理代码放在一个地方，这样未来的维护者只需要查看一个地方的代码，如果错误处理逻辑需要更改。将所有错误处理代码放在一个地方也将确保我们打印的消息对最终用户有意义。

让我们通过重构我们的项目来解决这四个问题。

### 二进制项目的关注点分离

将多个任务的责任分配给`main`函数的组织问题在许多二进制项目中很常见。因此，Rust 社区已经制定了在`main`开始变大时分割二进制程序的不同关注点的指导方针。这个过程有以下步骤：

- 将程序分为 main.rs 文件和 lib.rs 文件，并将程序的逻辑移至 lib.rs。
- 只要命令行解析逻辑很小，它可以保留在 main.rs 中。
- 当命令行解析逻辑开始变得复杂时，从 main.rs 中提取它并将其移至 lib.rs。

在此过程之后，`main`函数中剩余的责任应限于以下几点：

- 使用参数值调用命令行解析逻辑
- 设置任何其他配置
- 调用 lib.rs 中的`run`函数
- 如果`run`返回错误，则处理该错误

这种模式是关于分离关注点的：main.rs 处理程序的运行，lib.rs 处理手头任务的所有逻辑。因为你不能直接测试`main`函数，这种结构让你可以通过将所有程序逻辑移到 lib.rs 中的函数来测试它。main.rs 中剩余的代码将足够小，可以通过阅读来验证其正确性。让我们按照这个过程重新设计我们的程序。

#### 提取参数解析器

我们将把解析参数的功能提取到一个函数中，`main`将调用该函数，为将命令行解析逻辑移至 src/lib.rs 做准备。示例 12-5 显示了`main`的新开始，它调用了一个新函数`parse_config`，我们暂时将在 src/main.rs 中定义它。

文件名：src/main.rs：

```rust
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, file_path) = parse_config(&args);

    // --snip--

    println!("Searching for {query}");
    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let file_path = &args[2];

    (query, file_path)
}
```

示例 12-5：从`main`中提取`parse_config`函数

我们仍然将命令行参数收集到一个向量中，但是我们不再在`main`函数中将索引 1 处的参数值分配给变量`query`和索引 2 处的参数值分配给变量`file_path`，而是将整个向量传递给`parse_config`函数。`parse_config`函数然后保存确定哪个参数对应哪个变量的逻辑，并将值传回`main`。我们仍然在`main`中创建`query`和`file_path`变量，但`main`不再负责确定命令行参数和变量如何对应。

对于我们的小程序来说，这种重构可能看起来有些过度，但我们正在以小的、渐进的步骤进行重构。在做出这个改变后，再次运行程序以验证参数解析仍然有效。经常检查你的进展是很好的，这有助于在问题发生时识别原因。

#### 分组配置值
