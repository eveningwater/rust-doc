## 比较性能：循环 vs. 迭代器

要确定是使用循环还是迭代器，你需要知道哪种实现更快：使用显式 `for` 循环的 `search` 函数版本还是使用迭代器的版本。

我们通过加载阿瑟·柯南·道尔的《福尔摩斯探案集》的全部内容到一个 `String` 中，并在内容中查找单词 "the" 来运行了一个基准测试。以下是使用 `for` 循环的 `search` 版本和使用迭代器版本的基准测试结果：

```rust
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

这两种实现的性能相似！我们在这里不解释基准测试代码，因为重点不是证明这两个版本是等价的，而是了解这两种实现在性能上的大致比较。

为了进行更全面的基准测试，你应该使用各种大小的文本作为 `contents`，使用不同的单词和不同长度的单词作为 `query`，以及各种其他变体进行检查。重点是：迭代器虽然是一种高级抽象，但编译后生成的代码与你手动编写的低级代码大致相同。迭代器是 Rust 的零成本抽象之一，这意味着使用抽象不会带来额外的运行时开销。这类似于 C++ 的原始设计者和实现者 Bjarne Stroustrup 在《C++ 基础》（2012）中对零开销的定义：

> 总的来说，C++ 实现遵循零开销原则：你不使用的东西，你无需为此付费。此外：你使用的东西，你无法手动编写得更好。

另一个例子取自一个音频解码器。解码算法使用线性预测数学运算，根据先前样本的线性函数来估计未来值。此代码使用迭代器链对作用域中的三个变量进行一些数学运算：一个 `buffer` 数据切片、一个包含 12 个 `coefficients` 的数组以及一个用于在 `qlp_shift` 中移动数据的量。我们在此示例中声明了变量但未给它们赋值；尽管此代码在其上下文之外没有太多意义，但它仍然是 Rust 如何将高级思想转化为低级代码的简洁、真实世界的示例。

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

为了计算 `prediction` 的值，此代码遍历 `coefficients` 中的 12 个值，并使用 `zip` 方法将系数与 `buffer` 中前 12 个值配对。然后，对于每对，我们将值相乘，将所有结果相加，并将总和中的位向右移动 `qlp_shift` 位。

音频解码器等应用程序中的计算通常最优先考虑性能。在这里，我们创建了一个迭代器，使用了两个适配器，然后消耗了值。这段 Rust 代码会编译成什么样的汇编代码？嗯，截至本文撰写时，它编译后与你手动编写的汇编代码相同。没有与迭代 `coefficients` 中的值相对应的循环：Rust 知道有 12 次迭代，因此它“展开”了循环。展开是一种优化，它消除了循环控制代码的开销，而是为循环的每次迭代生成重复的代码。

所有系数都存储在寄存器中，这意味着访问值非常快。运行时没有对数组访问进行边界检查。Rust 能够应用的所有这些优化使得生成的代码效率极高。现在你知道了这一点，你可以放心地使用迭代器和闭包了！它们使代码看起来更高级，但不会因此带来运行时性能损失。

## 总结

闭包和迭代器是受函数式编程语言思想启发的 Rust 特性。它们有助于 Rust 以低级性能清晰地表达高级思想。闭包和迭代器的实现不会影响运行时性能。这是 Rust 努力提供零成本抽象目标的一部分。

现在我们已经提高了 I/O 项目的表达能力，接下来让我们看看 `cargo` 的更多特性，这些特性将帮助我们将项目分享给世界。
