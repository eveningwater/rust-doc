## 泛型类型、特性和生命周期

每种编程语言都有工具来有效处理概念的重复。在Rust中，其中一种工具是泛型：具体类型或其他属性的抽象替代品。我们可以表达泛型的行为或它们如何相互关联，而无需知道在编译和运行代码时它们将被什么替代。

函数可以接受某种泛型类型的参数，而不是像i32或String这样的具体类型，就像它们接受未知值的参数来对多个具体值运行相同的代码一样。事实上，我们已经在第6章中使用了`Option<T>`，在第8章中使用了`Vec<T>`和`HashMap<K, V>`，以及在第9章中使用了`Result<T, E>`。在本章中，你将探索如何定义自己的类型、函数和方法与泛型！

首先，我们将回顾如何提取函数以减少代码重复。然后，我们将使用相同的技术从两个仅在参数类型上不同的函数中创建一个泛型函数。我们还将解释如何在结构体和枚举定义中使用泛型类型。

然后，你将学习如何以泛型方式使用特性来定义行为。你可以将特性与泛型类型结合起来，限制泛型类型只接受具有特定行为的类型，而不是任何类型。

最后，我们将讨论生命周期：一种泛型，它为编译器提供关于引用如何相互关联的信息。生命周期允许我们给编译器提供足够的关于借用值的信息，以便它可以确保引用在更多情况下有效，而不是没有我们的帮助。

### 通过提取函数消除重复

泛型允许我们用代表多种类型的占位符替换特定类型，以消除代码重复。在深入研究泛型语法之前，让我们首先看看如何通过提取函数来消除重复，这种方式不涉及泛型类型，而是用代表多个值的占位符替换特定值。然后，我们将应用相同的技术来提取泛型函数！通过了解如何识别可以提取到函数中的重复代码，你将开始识别可以使用泛型的重复代码。

我们将从清单10-1中的短程序开始，该程序查找列表中的最大数字。

文件名：src/main.rs：

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
    assert_eq!(*largest, 100);
}
```

清单10-1：查找列表中的最大数字

我们在变量number_list中存储一个整数列表，并在名为largest的变量中放置对列表中第一个数字的引用。然后，我们遍历列表中的所有数字，如果当前数字大于存储在largest中的数字，我们就替换该变量中的引用。但是，如果当前数字小于或等于目前为止看到的最大数字，变量不会改变，代码继续处理列表中的下一个数字。在考虑列表中的所有数字后，largest应该引用最大的数字，在这种情况下是100。

现在，我们的任务是在两个不同的数字列表中找到最大的数字。为此，我们可以选择复制清单10-1中的代码，并在程序的两个不同位置使用相同的逻辑，如清单10-2所示。

文件名：src/main.rs：

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

清单10-2：查找两个数字列表中的最大数字的代码

虽然这段代码有效，但复制代码既繁琐又容易出错。我们还必须记住在想要更改代码时在多个地方更新代码。

为了消除这种重复，我们将创建一个抽象，定义一个函数，该函数对作为参数传入的任何整数列表进行操作。这个解决方案使我们的代码更清晰，并让我们抽象地表达在列表中查找最大数字的概念。

在清单10-3中，我们将查找最大数字的代码提取到一个名为largest的函数中。然后，我们调用该函数来查找清单10-2中两个列表的最大数字。我们还可以在将来对任何其他i32值列表使用该函数。

文件名：src/main.rs：

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");
    assert_eq!(*result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
    assert_eq!(*result, 6000);
}
```

清单10-3：抽象代码以查找两个列表中的最大数字

largest函数有一个名为list的参数，它代表我们可能传递给函数的任何具体的i32值切片。因此，当我们调用函数时，代码在我们传入的特定值上运行。

总结一下，以下是我们从清单10-2更改为清单10-3所采取的步骤：

1. 识别重复代码。
2. 将重复代码提取到函数体中，并在函数签名中指定该代码的输入和返回值。
3. 更新重复代码的两个实例以调用函数。

接下来，我们将使用泛型采用相同的步骤来减少代码重复。就像函数体可以对抽象列表而不是特定值进行操作一样，泛型允许代码对抽象类型进行操作。

例如，假设我们有两个函数：一个在i32值切片中查找最大项，另一个在char值切片中查找最大项。我们如何消除这种重复呢？让我们来看看！
