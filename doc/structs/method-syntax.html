<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>方法语法 | rust语言中文文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/rust-doc/logo.svg">
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="一门赋予每个人构建可靠且高效软件能力的语言。">
    
    <link rel="preload" href="/rust-doc/assets/css/0.styles.c73659be.css" as="style"><link rel="preload" href="/rust-doc/assets/js/app.b4aa453a.js" as="script"><link rel="preload" href="/rust-doc/assets/js/2.8e1d7368.js" as="script"><link rel="preload" href="/rust-doc/assets/js/1.e0f7c23c.js" as="script"><link rel="preload" href="/rust-doc/assets/js/52.7432e965.js" as="script"><link rel="prefetch" href="/rust-doc/assets/js/10.10e9729b.js"><link rel="prefetch" href="/rust-doc/assets/js/11.eec788fd.js"><link rel="prefetch" href="/rust-doc/assets/js/12.f50da0fd.js"><link rel="prefetch" href="/rust-doc/assets/js/13.55edccc1.js"><link rel="prefetch" href="/rust-doc/assets/js/14.a716756e.js"><link rel="prefetch" href="/rust-doc/assets/js/15.62d65329.js"><link rel="prefetch" href="/rust-doc/assets/js/16.6a15cea6.js"><link rel="prefetch" href="/rust-doc/assets/js/17.07fcdc57.js"><link rel="prefetch" href="/rust-doc/assets/js/18.dfa72d75.js"><link rel="prefetch" href="/rust-doc/assets/js/19.87b04eff.js"><link rel="prefetch" href="/rust-doc/assets/js/20.121157cc.js"><link rel="prefetch" href="/rust-doc/assets/js/21.8b6468c9.js"><link rel="prefetch" href="/rust-doc/assets/js/22.2104dc8b.js"><link rel="prefetch" href="/rust-doc/assets/js/23.50eec74b.js"><link rel="prefetch" href="/rust-doc/assets/js/24.c4bc3db9.js"><link rel="prefetch" href="/rust-doc/assets/js/25.7daee9e8.js"><link rel="prefetch" href="/rust-doc/assets/js/26.dc546d27.js"><link rel="prefetch" href="/rust-doc/assets/js/27.08036cac.js"><link rel="prefetch" href="/rust-doc/assets/js/28.20877408.js"><link rel="prefetch" href="/rust-doc/assets/js/29.3727251b.js"><link rel="prefetch" href="/rust-doc/assets/js/3.f0d80f91.js"><link rel="prefetch" href="/rust-doc/assets/js/30.43813a37.js"><link rel="prefetch" href="/rust-doc/assets/js/31.40c05473.js"><link rel="prefetch" href="/rust-doc/assets/js/32.b55084bb.js"><link rel="prefetch" href="/rust-doc/assets/js/33.5245fdbf.js"><link rel="prefetch" href="/rust-doc/assets/js/34.de5334ee.js"><link rel="prefetch" href="/rust-doc/assets/js/35.e172279e.js"><link rel="prefetch" href="/rust-doc/assets/js/36.fe70be6d.js"><link rel="prefetch" href="/rust-doc/assets/js/37.428eb8af.js"><link rel="prefetch" href="/rust-doc/assets/js/38.eb38ec9b.js"><link rel="prefetch" href="/rust-doc/assets/js/39.e221e4a6.js"><link rel="prefetch" href="/rust-doc/assets/js/4.572bd15d.js"><link rel="prefetch" href="/rust-doc/assets/js/40.4c3648f2.js"><link rel="prefetch" href="/rust-doc/assets/js/41.778b4018.js"><link rel="prefetch" href="/rust-doc/assets/js/42.72febd8f.js"><link rel="prefetch" href="/rust-doc/assets/js/43.2329871d.js"><link rel="prefetch" href="/rust-doc/assets/js/44.cef41026.js"><link rel="prefetch" href="/rust-doc/assets/js/45.e88ef1a8.js"><link rel="prefetch" href="/rust-doc/assets/js/46.ae93a576.js"><link rel="prefetch" href="/rust-doc/assets/js/47.9325daca.js"><link rel="prefetch" href="/rust-doc/assets/js/48.abfc1ffa.js"><link rel="prefetch" href="/rust-doc/assets/js/49.c9f99b3d.js"><link rel="prefetch" href="/rust-doc/assets/js/5.ae005ef1.js"><link rel="prefetch" href="/rust-doc/assets/js/50.63a45f61.js"><link rel="prefetch" href="/rust-doc/assets/js/51.f61b3b69.js"><link rel="prefetch" href="/rust-doc/assets/js/53.68eb3195.js"><link rel="prefetch" href="/rust-doc/assets/js/54.895772b1.js"><link rel="prefetch" href="/rust-doc/assets/js/6.62658830.js"><link rel="prefetch" href="/rust-doc/assets/js/7.44029ed2.js"><link rel="prefetch" href="/rust-doc/assets/js/vendors~docsearch.3e3e72ff.js">
    <link rel="stylesheet" href="/rust-doc/assets/css/0.styles.c73659be.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust-doc/" class="home-link router-link-active"><!----> <span class="site-name">rust语言中文文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust-doc/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/eveningwater/rust-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/eveningwater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/rust-doc/doc/introduce/introduce.html" class="sidebar-link">Rust介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/getting-started/getting-started" class="sidebar-heading clickable"><span>入门</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/rust-doc/doc/guess-game/guess-game.html" class="sidebar-link">猜一猜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/common-concept/common-concept" class="sidebar-heading clickable"><span>常用的编程概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/understand-ownership/understand-ownership" class="sidebar-heading clickable"><span>认识所有权</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/structs/structs" class="sidebar-heading clickable open"><span>使用结构体来构造相关数据</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust-doc/doc/structs/defining-structs.html" class="sidebar-link">定义和实例化结构体</a></li><li><a href="/rust-doc/doc/structs/example-structs.html" class="sidebar-link">使用结构体的示例程序</a></li><li><a href="/rust-doc/doc/structs/method-syntax.html" aria-current="page" class="active sidebar-link">方法语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust-doc/doc/structs/method-syntax.html#方法语法" class="sidebar-link">方法语法</a></li><li class="sidebar-sub-header"><a href="/rust-doc/doc/structs/method-syntax.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/rust-doc/doc/enums/enums" class="sidebar-heading clickable"><span>枚举</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>附录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="方法语法"><a href="#方法语法" class="header-anchor">#</a> 方法语法</h2> <p>方法类似于函数：我们用 fn 关键字和名称声明它们，它们可以有参数和返回值，并且它们包含一些在从其他地方调用该方法时运行的代码。与函数不同，方法是在结构体（或枚举或特征对象，我们分别在<a href="/rust-doc/doc/enums/enums.html">第 6 章</a>和第 17 章中介绍）的上下文中定义的，并且它们的第一个参数始终是 self，它表示调用该方法的结构体的实例。</p> <h3 id="方法定义"><a href="#方法定义" class="header-anchor">#</a> 方法定义</h3> <p>让我们将以 Rectangle 实例为参数的 area 函数改为在 Rectangle 结构体上定义一个 area 方法，如示例 5-13 所示。</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        rect1<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 5-13：在 Rectangle 结构体上定义面积方法</p> <p>为了在 Rectangle 上下文中定义该函数，我们为 Rectangle 启动一个 impl（实现）块。此 impl 块内的所有内容都将与 Rectangle 类型相关联。然后，我们将 area 函数移到 impl 大括号内，并将签名中的第一个（在本例中是唯一的）参数更改为 self，并将它们放在主体内的所有位置。在 main 中，我们调用了 area 函数并将 rect1 作为参数传递，我们可以改用方法语法来调用 Rectangle 实例上的 area 方法。方法语法位于实例之后：我们添加一个点，后跟方法名称、括号和任何参数。</p> <p>在 area 的签名中，我们使用 &amp;self 而不是 <code>rectangle: &amp;Rectangle</code>。<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在 impl 块中，类型 Self 是 impl 块所针对类型的别名。方法的第一个参数必须有一个名为 self 且类型为 Self 的参数，因此 Rust 允许你在第一个参数位置仅使用名称 self 来缩写它。请注意，我们仍然需要在 self 简写前面使用 &amp; 来表示此方法借用了 Self 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中所做的那样。方法可以取得 self 的所有权，不可变地借用 self（就像我们在这里所做的那样），或者可变地借用 self（就像它们可以对任何其他参数那样）。</p> <p>我们在这里选择 &amp;self 的原因与在函数版本中使用 &amp;Rectangle 的原因相同：我们不想取得所有权，我们只想读取结构中的数据，而不是写入数据。如果我们想在方法执行的过程中更改调用该方法的实例，我们将使用 <code>&amp;mut self</code> 作为第一个参数。使用 self 作为第一个参数来取得实例所有权的方法很少见；这种技术通常用于当方法将 self 转换为其他内容并且你想阻止调用者在转换后使用原始实例时。</p> <p>除了提供方法语法和不必在每个方法的签名中重复 self 的类型之外，使用方法而不是函数的主要原因是为了组织代码。我们将可以使用类型实例执行的所有操作都放在一个 impl 块中，而不是让我们代码的未来用户在我们提供的库的各个地方搜索 Rectangle 的功能。</p> <p>请注意，我们可以选择将方法命名为与结构体字段相同的名称。例如，我们可以在 Rectangle 上定义一个名为 width 的方法：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">width</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> rect1<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The rectangle has a nonzero width; it is {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们选择让 width 方法在实例的 width 字段中的值大于 0 时返回 true，在值为 0 时返回 false：我们可以将同名方法中的字段用于任何目的。在 main 中，当我们在 rect1.width 后面加上括号时，Rust 知道我们指的是width方法。当我们不使用括号时，Rust 知道我们指的是width字段。</p> <p>通常（但并非总是如此），当我们将方法命名为与字段相同的名称时，我们希望它仅返回字段中的值而不执行任何其他操作。像这样的方法称为 getter，Rust 不会像其他一些语言那样为结构字段自动实现它们。Getter 很有用，因为你可以将字段设为私有，但将方法设为公共，从而允许对该字段的只读访问作为类型公共 API 的一部分。我们将在第 7 章中讨论什么是公共和私有，以及如何将字段或方法指定为公共或私有。</p> <blockquote><h3 id="操作符-在哪里"><a href="#操作符-在哪里" class="header-anchor">#</a> 操作符<code>-&gt;</code>在哪里？</h3> <p>在 C 和 C++ 中，调用方法使用两种不同的运算符：如果直接调用对象上的方法，则使用 <code>.</code>；如果调用指向对象的指针上的方法并需要先取消引用指针，则使用 <code>-&gt;</code>。换句话说，如果 object 是指针，则 <code>object-&gt;something()</code> 类似于 <code>(*object).something()</code>。
Rust 没有与 <code>-&gt;</code> 运算符等效的运算符；相反，Rust 具有一项称为自动引用和取消引用的功能。调用方法是 Rust 中少数具有此行为的地方之一。
它的工作原理如下：当你使用 <code>object.something()</code> 调用方法时，Rust 会自动添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code>，以便 object 与方法的签名匹配。换句话说，以下内容相同：</p> <div class="language-rust extra-class"><pre class="language-rust"><code>p1<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第一个看起来更简洁。这种自动引用行为之所以有效，是因为方法有一个明确的接收者——<code>self</code>类型。给定接收者和方法名称，Rust 可以明确地确定该方法是读取（<code>&amp;self</code>）、可变（<code>&amp;mut self</code>）还是消费（<code>self</code>）。Rust 使方法接收者的借用隐式化，这一事实在实践中是使所有权符合人体工程学的重要部分。</p></blockquote> <h3 id="具有更多参数的方法"><a href="#具有更多参数的方法" class="header-anchor">#</a> 具有更多参数的方法</h3> <p>让我们通过在 Rectangle 结构上实现第二个方法来练习使用方法。这次，我们希望 Rectangle 的一个实例接受另一个 Rectangle 实例，如果第二个 Rectangle 可以完全容纳在 self（第一个 Rectangle）中，则返回 true；否则，它应该返回 false。也就是说，一旦我们定义了 can_hold 方法，我们就希望能够编写如示例 5-14 所示的程序。</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect2 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect3 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect2? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect3? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 5-14：使用尚未编写的 can_hold 方法</p> <p>预期输出将如下所示，因为 rect2 的两个尺寸都小于 rect1 的尺寸，但 rect3 比 rect1 宽：</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token class-name">Can</span> rect1 hold rect2<span class="token operator">?</span> <span class="token boolean">true</span>
<span class="token class-name">Can</span> rect1 hold rect3<span class="token operator">?</span> <span class="token boolean">false</span>
</code></pre></div><p>我们知道我们想要定义一个方法，所以它将在 impl Rectangle 块中。方法名称将是 can_hold，它将以另一个 Rectangle 的不可变借用作为参数。我们可以通过查看调用该方法的代码来判断参数的类型：rect1.can_hold(&amp;rect2) 传入 &amp;rect2，它是 Rectangle 实例 rect2 的不可变借用。这是有道理的，因为我们只需要读取 rect2（而不是写入，这意味着我们需要一个可变借用），并且我们希望 main 保留 rect2 的所有权，以便在调用 can_hold 方法后再次使用它。can_hold 的返回值将是一个布尔值，实现将分别检查 self 的宽度和高度是否大于另一个 Rectangle 的宽度和高度。让我们将新的 can_hold 方法添加到示例 5-13 中的 impl 块中，如示例 5-15 所示。</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 5-15：实现 Rectangle 的 can_hold 方法，以另一个 Rectangle 实例作为参数</p> <p>当我们使用示例 5-14 中的 main 函数运行此代码时，我们将获得所需的输出。方法可以采用我们在 self 参数之后添加到签名中的多个参数，这些参数的工作方式与函数中的参数一样。</p> <h3 id="关联函数"><a href="#关联函数" class="header-anchor">#</a> 关联函数</h3> <p>impl 块中定义的所有函数都称为关联函数，因为它们与以 impl 命名的类型相关联。我们可以定义不以 self 作为其第一个参数的关联函数（因此不是方法），因为它们不需要使用该类型的实例即可工作。我们已经使用过一个这样的函数：在 String 类型上定义的 <code>String::from</code> 函数。</p> <p>不是方法的关联函数通常用于将返回结构体新实例的构造函数。这些通常被称为 new，但 new 不是特殊名称，也不是语言内置的。例如，我们可以选择提供一个名为 square 的关联函数，该函数有一个维度参数，并将其用作宽度和高度，从而更容易创建一个square相关的Rectangle结构体，而不必两次指定相同的值：</p> <p>文件名：src/main.rs:</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">square</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token keyword">Self</span> <span class="token punctuation">{</span>
            width<span class="token punctuation">:</span> size<span class="token punctuation">,</span>
            height<span class="token punctuation">:</span> size<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>返回类型和函数主体中的 Self 关键字是 impl 关键字后出现的类型的别名，在本例中为 Rectangle。</p> <p>要调用此关联函数，我们使用 <code>::</code> 语法和结构名称； <code>let sq = Rectangle::square(3);</code> 就是一个例子。此函数由结构命名空间：<code>::</code> 语法用于关联函数和模块创建的命名空间。我们将在第 7 章中讨论模块。</p> <h3 id="多个-impl-块"><a href="#多个-impl-块" class="header-anchor">#</a> 多个 impl 块</h3> <p>每个结构体允许有多个 impl 块。例如，示例 5-15 相当于示例 5-16 所示的代码，其中每个方法都在自己的 impl 块中。</p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>示例 5-16：使用多个 impl 块重写示例 5-15</p> <p>这里没有必要将这些方法分成多个 impl 块，但这是有效的语法。我们将在第 10 章中看到多个 impl 块有用的情况，我们将在该章中讨论泛型类型和特征。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>结构体允许你创建对你的领域有意义的自定义类型。通过使用结构体，你可以将关联的数据片段彼此连接，并命名每个片段以使你的代码清晰易懂。在 impl 块中，你可以定义与你的类型关联的函数，方法是一种关联函数，可让你指定结构体实例的行为。</p> <p>但结构体并不是创建自定义类型的唯一方式：让我们转向 Rust 的枚举功能，为你的工具箱添加另一个工具。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/rust-doc/doc/structs/example-structs.html" class="prev">
        使用结构体的示例程序
      </a></span> <span class="next"><a href="/rust-doc/doc/enums/defining-an-enum.html">
        定义一个枚举
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/rust-doc/assets/js/app.b4aa453a.js" defer></script><script src="/rust-doc/assets/js/2.8e1d7368.js" defer></script><script src="/rust-doc/assets/js/1.e0f7c23c.js" defer></script><script src="/rust-doc/assets/js/52.7432e965.js" defer></script>
  </body>
</html>
