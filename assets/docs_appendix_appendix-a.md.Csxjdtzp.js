import{_ as s,c as a,o as l,ag as t}from"./chunks/framework.CO45oJKY.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/appendix/appendix-a.md","filePath":"docs/appendix/appendix-a.md","lastUpdated":1754619623000}'),n={name:"docs/appendix/appendix-a.md"};function h(p,i,e,k,r,d){return l(),a("div",null,i[0]||(i[0]=[t(`<h2 id="附录-a-关键字" tabindex="-1">附录 A：关键字 <a class="header-anchor" href="#附录-a-关键字" aria-label="Permalink to &quot;附录 A：关键字&quot;">​</a></h2><p>以下列表包含 Rust 语言为当前或未来使用而保留的关键字。因此，它们不能用作标识符（除了我们将在“<a href="#原始标识符">原始标识符</a>”部分讨论的原始标识符）。标识符是函数、变量、参数、结构字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期的名称。</p><h2 id="当前使用的关键字" tabindex="-1">当前使用的关键字 <a class="header-anchor" href="#当前使用的关键字" aria-label="Permalink to &quot;当前使用的关键字&quot;">​</a></h2><p>以下是当前使用的关键字列表及其功能描述。</p><ul><li>as - 执行原始转换，消除包含项目的特定特征的歧义，或在 use 语句中重命名项目</li><li>async - 返回 Future 而不是阻止当前线程 (Future 表示一个可能还没有计算完成的值，或者是一个可以在将来某个时刻完成的操作。)</li><li>await - 暂停执行，直到 Future 的结果准备就绪</li><li>break - 立即退出循环</li><li>const - 定义常量项目或常量原始指针</li><li>continue - 继续进行下一次循环迭代</li><li>crate - 在模块路径中，引用 crate 根</li><li>dyn - 动态分派到特征对象</li><li>else - if 和 if let 控制流构造的回退</li><li>enum - 定义枚举</li><li>extern - 链接外部函数或变量</li><li>false - 布尔 false 文字</li><li>fn - 定义函数或函数指针类型</li><li>for - 循环遍历迭代器中的项目，实现特征或指定更高级别的生命周期</li><li>if - 根据条件表达式的结果进行分支</li><li>impl - 实现固有或特征功能</li><li>in - for 循环语法的一部分</li><li>let - 绑定变量</li><li>loop - 无条件循环</li><li>match - 将值与模式匹配</li><li>mod - 定义 module</li><li>move - 使闭包拥有其所有捕获的所有权</li><li>mut - 表示引用、原始指针或模式绑定中的可变性</li><li>pub - 表示结构字段、impl 块或模块中的公共可见性</li><li>ref - 通过引用绑定</li><li>return - 从函数返回</li><li>Self - 我们正在定义或实现的类型的类型别名</li><li>self - 方法主体或当前模块</li><li>static - 全局变量或持续整个程序执行的生命周期</li><li>struct - 定义结构</li><li>super - 当前模块的父模块</li><li>trait - 定义特征</li><li>true - 布尔真文字</li><li>type - 定义类型别名或关联类型</li><li>union - 定义<a href="https://doc.rust-lang.org/reference/items/unions.html" target="_blank" rel="noreferrer">联合</a>；仅在联合声明中使用时才是关键字</li><li>unsafe - 表示不安全的代码、函数、特征或实现</li><li>use - 将符号带入范围</li><li>where - 表示约束类型的子句</li><li>while - 根据表达式的结果有条件地循环</li></ul><h2 id="为将来使用而保留的关键字" tabindex="-1">为将来使用而保留的关键字 <a class="header-anchor" href="#为将来使用而保留的关键字" aria-label="Permalink to &quot;为将来使用而保留的关键字&quot;">​</a></h2><p>以下关键字尚不具备任何功能，但由 Rust 保留以供将来使用。</p><ul><li>abstract</li><li>become</li><li>box</li><li>do</li><li>final</li><li>macro</li><li>override</li><li>priv</li><li>try</li><li>typeof</li><li>unsized</li><li>virtual</li><li>yield</li></ul><h2 id="原始标识符" tabindex="-1">原始标识符 <a class="header-anchor" href="#原始标识符" aria-label="Permalink to &quot;原始标识符&quot;">​</a></h2><p>原始标识符是一种语法，它允许你在通常不允许使用关键字的地方使用关键字。你可以通过在关键字前加上 <code>r#</code> 来使用原始标识符。</p><p>例如，match 是一个关键字。如果你尝试编译以下使用 match 作为其名称的函数：</p><p>文件名：src/main.rs</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(needle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, haystack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    haystack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(needle)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你将收到此错误：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> expected</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> identifier,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> found</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyword</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> --</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">src/main.rs:4:4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">needle:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> haystack:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bool</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ^^^^^</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> expected</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> identifier,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> found</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyword</span></span></code></pre></div><p>错误表明你不能使用关键字 match 作为函数标识符。要将 match 用作函数名，你需要使用原始标识符语法，如下所示：</p><p>文件名：src/main.rs</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> r#match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(needle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, haystack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    haystack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(needle)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assert!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">r#match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foobar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>此代码将编译而不会出现任何错误。请注意函数定义中函数名称的 <code>r#</code> 前缀以及在 main 中调用该函数的位置。</p><p>原始标识符允许你使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。这让我们可以更自由地选择标识符名称，并让我们能够与使用这些单词不是关键字的语言编写的程序集成。此外，原始标识符允许你使用与当前依赖项使用的 Rust 版本不同的版本编写的库。例如，try 在 2015 版中不是关键字，但在 2018 版中是关键字。如果你依赖使用 2015 版编写且具有 try 函数的库，则需要使用原始标识符语法（在本例中为 <code>r#try</code>）从 2018 版代码中调用该函数。有关版本的更多信息，请参阅<a href="./appendix-e.html">附录 E</a>。</p>`,20)]))}const g=s(n,[["render",h]]);export{F as __pageData,g as default};
