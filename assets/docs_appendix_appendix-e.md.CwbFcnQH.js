import{_ as e,c as s,o as a,ag as o}from"./chunks/framework.CO45oJKY.js";const R=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/appendix/appendix-e.md","filePath":"docs/appendix/appendix-e.md"}'),p={name:"docs/appendix/appendix-e.md"};function r(d,t,u,i,n,c){return a(),s("div",null,t[0]||(t[0]=[o('<h2 id="附录-e-版本" tabindex="-1">附录 E - 版本 <a class="header-anchor" href="#附录-e-版本" aria-label="Permalink to &quot;附录 E - 版本&quot;">​</a></h2><p>在第1章中，你看到 <code>cargo new</code> 向你的 Cargo.toml 文件添加了一些关于版本的元数据。本附录讨论这意味着什么！</p><p>Rust 语言和编译器有一个六周的发布周期，这意味着用户会获得源源不断的新功能。其他编程语言不太频繁地发布更大的更改；Rust 更频繁地发布较小的更新。过一段时间，所有这些微小的更改会累积起来。但是从一个发布到另一个发布，很难回顾并说，&quot;哇，在 Rust 1.10 和 Rust 1.31 之间，Rust 改变了很多！&quot;</p><p>大约每三年，Rust 团队会制作一个新的 Rust <strong>版本</strong>（<em>edition</em>）。每个版本将已经落地的功能整合到一个清晰的包中，配有完全更新的文档和工具。新版本作为常规六周发布流程的一部分发布。</p><p>版本为不同的人服务不同的目的：</p><ul><li>对于活跃的 Rust 用户，新版本将增量更改整合到一个易于理解的包中。</li><li>对于非用户，新版本表明一些重大进步已经落地，这可能使 Rust 值得再次关注。</li><li>对于那些开发 Rust 的人，新版本为整个项目提供了一个凝聚点。</li></ul><p>在撰写本文时，有四个 Rust 版本可用：Rust 2015、Rust 2018、Rust 2021 和 Rust 2024。本书使用 Rust 2024 版本的习惯用法编写。</p><p>Cargo.toml 中的 <code>edition</code> 键指示编译器应该为你的代码使用哪个版本。如果该键不存在，出于向后兼容性的原因，Rust 使用 2015 作为版本值。</p><p>每个项目都可以选择使用默认 2015 版本以外的版本。版本可能包含不兼容的更改，例如包含与代码中的标识符冲突的新关键字。但是，除非你选择使用这些更改，否则即使你升级使用的 Rust 编译器版本，你的代码也会继续编译。</p><p>所有 Rust 编译器版本都支持在该编译器发布之前存在的任何版本，并且它们可以将任何支持版本的 <code>crate</code> 链接在一起。版本更改只影响编译器最初解析代码的方式。因此，如果你使用 Rust 2015 而你的依赖项之一使用 Rust 2018，你的项目将编译并能够使用该依赖项。相反的情况，你的项目使用 Rust 2018 而依赖项使用 Rust 2015，也同样有效。</p><p>需要明确的是：大多数功能将在所有版本上可用。使用任何 Rust 版本的开发者将在新的稳定版本发布时继续看到改进。但是，在某些情况下，主要是当添加新关键字时，一些新功能可能只在后续版本中可用。如果你想利用这些功能，你需要切换版本。</p><p>有关更多详细信息，<a href="https://doc.rust-lang.org/stable/edition-guide/" target="_blank" rel="noreferrer">版本指南</a>是一本关于版本的完整书籍，它列举了版本之间的差异，并解释了如何通过 <code>cargo fix</code> 自动将你的代码升级到新版本。</p>',12)]))}const _=e(p,[["render",r]]);export{R as __pageData,_ as default};
