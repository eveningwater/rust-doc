(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{381:function(t,s,a){"use strict";a.r(s);var n=a(17),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),s("p",[t._v("Rust 中的每个值都属于特定的数据类型，这告诉 Rust 指定了哪种数据，以便它知道如何处理这些数据。我们将研究两种数据类型子集：标量和复合。")]),t._v(" "),s("p",[t._v("请记住，Rust 是一种静态类型语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值及其使用方式推断出我们想要使用的类型。在可能存在多种类型的情况下，例如当我们在第 2 章的“"),s("RouterLink",{attrs:{to:"/doc/common-concept/guess-game.html#将猜测数字与秘密数字进行比较"}},[t._v("将猜测数字与秘密数字进行比较")]),t._v("”部分中使用 "),s("code",[t._v("parse")]),t._v(" 将字符串转换为数字类型时，我们必须添加类型注释，如下所示：")],1),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("如果我们不添加上述代码中所示的 "),s("code",[t._v(":u32")]),t._v(" 类型注释，Rust 将显示以下错误，这意味着编译器需要我们提供更多信息来知道我们要使用哪种类型：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo build\n   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Compiling")]),t._v(" no_type_annotations v0"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//projects/no_type_annotations)")]),t._v("\nerror"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("E0284")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("annotations")]),t._v(" needed\n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" src"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("         "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("must")]),t._v(" be known at this point\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" note"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" cannot satisfy `"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("_ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FromStr")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Err")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" _`\nhelp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" consider giving `guess` an explicit "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Type */")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("              "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("For")]),t._v(" more information about this error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" `rustc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("explain "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("E0284")]),t._v("`"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nerror"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" could not compile `no_type_annotations` "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bin "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"no_type_annotations"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" due to "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" previous error\n")])])]),s("p",[t._v("你将看到其他数据类型的不同类型注释。")]),t._v(" "),s("h3",{attrs:{id:"标量类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标量类型"}},[t._v("#")]),t._v(" 标量类型")]),t._v(" "),s("p",[t._v("标量类型表示单个值。Rust 有四种主要标量类型：整数、浮点数、布尔值和字符(注意与字符串的区别,rust 有字符和字符串两种类型，字符串将在后面介绍)。你可能在其他编程语言中见过这些类型。让我们来看看它们在 Rust 中的工作原理。")]),t._v(" "),s("h4",{attrs:{id:"整数类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数类型"}},[t._v("#")]),t._v(" 整数类型")]),t._v(" "),s("p",[t._v("整数是没有小数部分的数字。我们在第 2 章中使用了一种整数类型，即 u32 类型。此类型声明表示它所关联的值应为无符号整数（有符号整数类型以 i 而不是 u 开头），占用 32 位空间。表 3-1 显示了 Rust 中的内置整数类型。我们可以使用这些变量中的任何一种来声明整数值的类型。")]),t._v(" "),s("p",[t._v("表 3-1: Rust 中的整数类型")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("长度")]),t._v(" "),s("th",[t._v("有符号")]),t._v(" "),s("th",[t._v("无符号")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("8-bit")]),t._v(" "),s("td",[t._v("i8")]),t._v(" "),s("td",[t._v("u8")])]),t._v(" "),s("tr",[s("td",[t._v("16-bit")]),t._v(" "),s("td",[t._v("i16")]),t._v(" "),s("td",[t._v("u16")])]),t._v(" "),s("tr",[s("td",[t._v("32-bit")]),t._v(" "),s("td",[t._v("i32")]),t._v(" "),s("td",[t._v("u32")])]),t._v(" "),s("tr",[s("td",[t._v("64-bit")]),t._v(" "),s("td",[t._v("i64")]),t._v(" "),s("td",[t._v("u64")])]),t._v(" "),s("tr",[s("td",[t._v("128-bit")]),t._v(" "),s("td",[t._v("i128")]),t._v(" "),s("td",[t._v("u128")])]),t._v(" "),s("tr",[s("td",[t._v("arch(架构)")]),t._v(" "),s("td",[t._v("isize")]),t._v(" "),s("td",[t._v("usize")])])])]),t._v(" "),s("p",[t._v("每个变量可以是有符号的，也可以是无符号的，并且具有明确的大小。有符号和无符号指的是数字是否可能为负数，换句话说，数字是否需要带有符号（有符号）或者它是否永远都是正数，因此可以不用符号表示（无符号）。这就像在纸上写数字：当符号很重要时，数字会显示加号或减号；但是，当可以安全地假设数字为正数时，它不会显示符号。有符号数字使用"),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Two%27s_complement",target:"_blank",rel:"noopener noreferrer"}},[t._v("二进制补码表示法"),s("OutboundLink")],1),t._v("存储。")]),t._v(" "),s("p",[t._v("每个有符号变量可以存储从 -(2"),s("sup",[t._v("n - 1")]),t._v(") 到 2"),s("sup",[t._v("n - 1")]),t._v(" - 1（含）的数字，其中 n 是变量使用的位数。因此，i8 可以存储从 -(2"),s("sup",[t._v("7")]),t._v(") 到 2"),s("sup",[t._v("7")]),t._v(" - 1（等于 -128 到 127）的数字。无符号变量可以存储从 0 到 2"),s("sup",[t._v("n")]),t._v(" - 1 的数字，因此 u8 可以存储从 0 到 2"),s("sup",[t._v("8")]),t._v(" - 1（等于 0 到 255）的数字。")]),t._v(" "),s("p",[t._v("此外，isize 和 usize 类型取决于程序所运行的计算机的体系结构，在表 3-1 中表示为“arch(可以理解是架构的意思)一行”：如果使用 64 位体系结构，则为 64 位；如果使用 32 位体系结构，则为 32 位。")]),t._v(" "),s("p",[t._v("你可以采用表 3-2 中所示的任何一种形式来编写整数文字。请注意，可以为多种数字类型的数字文字允许使用类型后缀（例如"),s("code",[t._v("57u8")]),t._v("）来指定类型。数字文字还可以使用 "),s("code",[t._v("_")]),t._v(" 作为视觉分隔符，使数字更易于阅读，例如 "),s("code",[t._v("1_000")]),t._v("，其值与你指定 1000 时的值相同。")]),t._v(" "),s("p",[t._v("表 3-2: rust 中的整数文字")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("数值文字")]),t._v(" "),s("th",[t._v("示例")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Decimal")]),t._v(" "),s("td",[t._v("98_222")])]),t._v(" "),s("tr",[s("td",[t._v("Hex")]),t._v(" "),s("td",[t._v("0xff")])]),t._v(" "),s("tr",[s("td",[t._v("Octal")]),t._v(" "),s("td",[t._v("0o77")])]),t._v(" "),s("tr",[s("td",[t._v("Binary")]),t._v(" "),s("td",[t._v("0b1111_0000")])]),t._v(" "),s("tr",[s("td",[t._v("Byte (u8 only)")]),t._v(" "),s("td",[t._v("b'A'")])])])]),t._v(" "),s("p",[t._v("那么你如何知道要使用哪种类型的整数？如果你不确定，Rust 的默认值通常是不错的起点：整数类型默认为 i32。你使用 isize 或 usize 的主要情况是索引某种集合时。")]),t._v(" "),s("blockquote",[s("h5",{attrs:{id:"整数溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数溢出"}},[t._v("#")]),t._v(" 整数溢出")]),t._v(" "),s("p",[t._v("假设你有一个 u8 类型的变量，它可以保存 0 到 255 之间的值。如果你尝试将变量更改为该范围之外的值（例如 256），则会发生整数溢出，这可能导致两种行为之一。在调试模式下编译时，Rust 会检查整数溢出，如果发生此行为，则会导致程序在运行时崩溃。Rust 在程序因错误退出时使用术语“崩溃”；我们将在第 9 章的“无法恢复的崩溃错误！”部分更深入地讨论崩溃。")]),t._v(" "),s("p",[t._v("在使用 "),s("code",[t._v("--release")]),t._v(" 标志在发布模式下编译时，Rust 不会检查导致崩溃的整数溢出。相反，如果发生溢出，Rust 会执行二进制补码包装。简而言之，大于类型可以保存的最大值的值“包装”到类型可以保存的最小值。对于 u8，值 256 变为 0，值 257 变为 1，依此类推。程序不会崩溃，但变量的值可能不是你预期的值。依赖整数溢出的包装行为被视为错误。")]),t._v(" "),s("p",[t._v("要明确处理溢出的可能性，你可以使用标准库为原始数字类型提供的这些方法系列：")]),t._v(" "),s("ul",[s("li",[t._v("使用 "),s("code",[t._v("wrapping_*")]),t._v(" 方法（例如"),s("code",[t._v("wrapping_add")]),t._v("）在所有模式下包装。")]),t._v(" "),s("li",[t._v("如果使用 "),s("code",[t._v("checked_*")]),t._v(" 方法发生溢出，则返回 None 值。")]),t._v(" "),s("li",[t._v("返回 "),s("code",[t._v("overflowing_*")]),t._v(" 方法的值和一个布尔值，指示是否发生溢出。")]),t._v(" "),s("li",[t._v("使用 "),s("code",[t._v("saturating_*")]),t._v(" 方法在值的最小值或最大值处饱和。")])])]),t._v(" "),s("h4",{attrs:{id:"浮点类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浮点类型"}},[t._v("#")]),t._v(" 浮点类型")]),t._v(" "),s("p",[t._v("Rust 还具有两种浮点数基本类型，即带有小数点的数字。Rust 的浮点类型是 f32 和 f64，大小分别为 32 位和 64 位。默认类型为 f64，因为在现代 CPU 上，它的速度与 f32 大致相同，但精度更高。所有浮点类型都是有符号的。")]),t._v(" "),s("p",[t._v("下面是一个展示浮点数实际作用的示例：")]),t._v(" "),s("p",[t._v("文件名: main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// f64")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// f32")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("浮点数按照 IEEE-754 标准表示。f32 类型为单精度浮点数，f64 为双精度浮点数。")]),t._v(" "),s("h4",{attrs:{id:"数值运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数值运算"}},[t._v("#")]),t._v(" 数值运算")]),t._v(" "),s("p",[t._v("Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和余数。整数除法会将数字截断为最接近的整数。以下代码显示了如何在 let 语句中使用每个数字运算：")]),t._v(" "),s("p",[t._v("文件名: main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 加法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 减法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" difference "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("95.5")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 乘法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" product "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 除法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" quotient "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("56.7")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("32.2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" truncated "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 结果是-1")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 余数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" remainder "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("43")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这些语句中的每个表达式都使用数学运算符并计算出一个值，然后将其绑定到变量。"),s("RouterLink",{attrs:{to:"/doc/common-concept/appendix-b.html"}},[t._v("附录 B")]),t._v(" 包含 Rust 提供的所有运算符的列表。")],1),t._v(" "),s("h4",{attrs:{id:"布尔类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型"}},[t._v("#")]),t._v(" 布尔类型")]),t._v(" "),s("p",[t._v("与大多数其他编程语言一样，Rust 中的布尔类型有两个可能的值：true 和 false。布尔值的大小为一个字节。Rust 中的布尔类型使用 bool 指定。例如：")]),t._v(" "),s("p",[t._v("文件名: main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 显式类型注释")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("使用布尔值的主要方式是通过条件，例如 if 表达式。我们将在“"),s("RouterLink",{attrs:{to:"/doc/common-concept/control-flow.html"}},[t._v("控制流")]),t._v("”部分介绍 if 表达式在 Rust 中的工作原理。")],1),t._v(" "),s("h4",{attrs:{id:"字符类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符类型"}},[t._v("#")]),t._v(" 字符类型")]),t._v(" "),s("p",[t._v("Rust 的 char 类型是该语言最原始的字符类型。以下是声明 char 值的一些示例：")]),t._v(" "),s("p",[t._v("文件名: main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'z'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token char"}},[t._v("'ℤ'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 显式类型注释")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" heart_eyed_cat "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" '😻'"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("请注意，我们用单引号指定 char 文字，而不是使用双引号的字符串文字。Rust 的 char 类型大小为四个字节，表示 Unicode 标量值，这意味着它可以表示的不仅仅是 ASCII。重音字母；中文、日文和韩文字符；表情符号；以及零宽度空格都是 Rust 中的有效 char 值。Unicode 标量值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （含）。但是，“字符”在 Unicode 中并不是一个真正的概念，因此你对“字符”的人类直觉可能与 Rust 中的 char 不匹配。我们将在第 8 章“使用字符串存储 UTF-8 编码文本”中详细讨论这个主题。")])])}),[],!1,null,null,null);s.default=r.exports}}]);