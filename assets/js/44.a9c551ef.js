(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{391:function(t,s,a){"use strict";a.r(s);var n=a(17),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"定义一个枚举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义一个枚举"}},[t._v("#")]),t._v(" 定义一个枚举")]),t._v(" "),s("p",[t._v("结构体为你提供了一种将相关字段和数据组合在一起的方法，例如具有width和height的 Rectangle，而枚举为你提供了一种表示某个值是一组可能值之一的方法。例如，我们可能想说 Rectangle 是一组可能形状之一，该集合还包括 Circle 和 Triangle。为此，Rust 允许我们将这些可能性编码为枚举。")]),t._v(" "),s("p",[t._v("让我们看看我们可能想要在代码中表达的情况，看看为什么枚举在这种情况下比结构更有用、更合适。假设我们需要处理 IP 地址。目前，IP 地址使用两个主要标准：v4 和 v6。因为这些是我们的程序会遇到的唯一可能的 IP 地址，所以我们可以枚举所有可能的变量，这就是枚举名称的由来。")]),t._v(" "),s("p",[t._v("任何 IP 地址都可以是v4 或v6地址，但不能同时是两者。IP 地址的这一特性使得枚举数据结构非常合适，因为枚举值只能是其变体之一。v4 和v6地址从根本上来说仍然是 IP 地址，因此当代码处理适用于任何类型的 IP 地址的情况时，应将它们视为同一类型。")]),t._v(" "),s("p",[t._v("我们可以通过定义 IpAddrKind 枚举并列出 IP 地址可能的类型 V4 和 V6，在代码中表达这一概念。这些是枚举的变体：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("IpAddrKind")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("V4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("V6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("IpAddrKind 现在是一种自定义数据类型，我们可以在代码的其他地方使用它。")]),t._v(" "),s("h3",{attrs:{id:"枚举值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举值"}},[t._v("#")]),t._v(" 枚举值")])])}),[],!1,null,null,null);s.default=e.exports}}]);