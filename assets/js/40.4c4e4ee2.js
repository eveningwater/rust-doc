(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{390:function(t,a,s){"use strict";s.r(a);var e=s(18),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏"}},[t._v("#")]),t._v(" 宏")]),t._v(" "),a("p",[t._v("我们在本文档网站中一直使用像"),a("code",[t._v("println!")]),t._v("这样的宏，但我们还没有完全探索宏是什么以及它是如何工作的。术语宏指的是Rust中的一系列功能：带有"),a("code",[t._v("macro_rules!")]),t._v("的声明式宏和三种过程宏：")]),t._v(" "),a("ul",[a("li",[t._v("自定义"),a("code",[t._v("#[derive]")]),t._v("宏，指定与在"),a("code",[t._v("struct")]),t._v("和"),a("code",[t._v("enum")]),t._v("上使用的"),a("code",[t._v("derive")]),t._v("属性一起添加的代码")]),t._v(" "),a("li",[t._v("类似属性的宏，定义可在任何项上使用的自定义属性")]),t._v(" "),a("li",[t._v("类似函数的宏，看起来像函数调用，但对指定为其参数的"),a("code",[t._v("token")]),t._v("进行操作")])]),t._v(" "),a("p",[t._v("我们将依次讨论这些内容，但首先，让我们看看当我们已经有函数时，为什么我们还需要宏。")]),t._v(" "),a("h3",{attrs:{id:"宏和函数之间的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏和函数之间的区别"}},[t._v("#")]),t._v(" 宏和函数之间的区别")]),t._v(" "),a("p",[t._v("从根本上说，宏是一种编写代码来编写其他代码的方式，这被称为元编程。在附录C中，我们讨论了"),a("code",[t._v("derive")]),t._v("属性，它为你生成各种"),a("code",[t._v("trait")]),t._v("的实现。我们在整本文档网站中也使用了"),a("code",[t._v("println!")]),t._v("和"),a("code",[t._v("vec!")]),t._v("宏。所有这些宏都会展开以生成比你手动编写的代码更多的代码。")]),t._v(" "),a("p",[t._v("元编程对于减少你必须编写和维护的代码数量很有用，这也是函数的作用之一。然而，宏有一些函数没有的额外功能。")]),t._v(" "),a("p",[t._v("函数签名必须声明函数具有的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用"),a("code",[t._v('println!("hello")')]),t._v("，或者用两个参数调用"),a("code",[t._v('println!("hello {}", name)')]),t._v("。此外，宏在编译器解释代码含义之前展开，因此宏可以，例如，在给定类型上实现"),a("code",[t._v("trait")]),t._v("。函数不能这样做，因为它在运行时被调用，而"),a("code",[t._v("trait")]),t._v("需要在编译时实现。")]),t._v(" "),a("p",[t._v("实现宏而不是函数的缺点是宏定义比函数定义更复杂，因为你在编写编写Rust代码的Rust代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。")]),t._v(" "),a("p",[t._v("宏和函数之间的另一个重要区别是，你必须在文件中调用宏之前定义宏或将其引入作用域，而不是函数，你可以在任何地方定义并在任何地方调用。")]),t._v(" "),a("h3",{attrs:{id:"使用macro-rules-进行通用元编程的声明式宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用macro-rules-进行通用元编程的声明式宏"}},[t._v("#")]),t._v(" 使用"),a("code",[t._v("macro_rules!")]),t._v("进行通用元编程的声明式宏")]),t._v(" "),a("p",[t._v('Rust中最广泛使用的宏形式是声明式宏。这些有时也被称为"示例宏"、"'),a("code",[t._v("macro_rules!")]),t._v('宏"或简称为"宏"。声明式宏的核心允许你编写类似于Rust '),a("code",[t._v("match")]),t._v("表达式的东西。正如第6章中讨论的，"),a("code",[t._v("match")]),t._v("表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也将值与与特定代码关联的模式进行比较：在这种情况下，值是传递给宏的字面Rust源代码；模式与该源代码的结构进行比较；与每个模式关联的代码在匹配时替换传递给宏的代码。这一切都在编译期间发生。")]),t._v(" "),a("p",[t._v("要定义宏，你使用"),a("code",[t._v("macro_rules!")]),t._v("构造。让我们通过查看"),a("code",[t._v("vec!")]),t._v("宏是如何定义的来探索如何使用"),a("code",[t._v("macro_rules!")]),t._v("。第8章介绍了我们如何使用"),a("code",[t._v("vec!")]),t._v("宏创建具有特定值的新向量。例如，以下宏创建一个包含三个整数的新向量：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#![allow(unused)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("vec!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("我们也可以使用"),a("code",[t._v("vec!")]),t._v("宏创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们无法使用函数做同样的事情，因为我们不会提前知道值的数量或类型。")]),t._v(" "),a("p",[t._v("示例20-35显示了"),a("code",[t._v("vec!")]),t._v("宏的稍微简化的定义。")]),t._v(" "),a("p",[t._v("文件名：src/lib.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[macro_export]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("macro_rules!")]),t._v(" vec "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token fragment-specifier punctuation"}},[t._v("expr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" temp_vec "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n                temp_vec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n            temp_vec\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-35："),a("code",[t._v("vec!")]),t._v("宏定义的简化版本")]),t._v(" "),a("blockquote",[a("p",[t._v("注意：标准库中"),a("code",[t._v("vec!")]),t._v("宏的实际定义包括预先分配正确内存量的代码。该代码是一个优化，我们在这里不包括它，以使示例更简单。")])]),t._v(" "),a("p",[a("code",[t._v("#[macro_export]")]),t._v("注解表示每当定义宏的"),a("code",[t._v("crate")]),t._v("被引入作用域时，这个宏就应该可用。如果没有这个注解，宏就不能被引入作用域。")]),t._v(" "),a("p",[t._v("然后我们用"),a("code",[t._v("macro_rules!")]),t._v("和我们正在定义的宏的名称（不带感叹号）开始宏定义。在这种情况下，名称"),a("code",[t._v("vec")]),t._v("后跟花括号，表示宏定义的主体。")]),t._v(" "),a("p",[a("code",[t._v("vec!")]),t._v("主体中的结构类似于"),a("code",[t._v("match")]),t._v("表达式的结构。这里我们有一个带有模式"),a("code",[t._v("( $( $x:expr ),* )")]),t._v("的分支，后跟"),a("code",[t._v("=>")]),t._v("和与此模式关联的代码块。如果模式匹配，将发出关联的代码块。鉴于这是此宏中的唯一模式，只有一种有效的匹配方式；任何其他模式都会导致错误。更复杂的宏将有多个分支。")]),t._v(" "),a("p",[t._v("宏定义中的有效模式语法与第19章中涵盖的模式语法不同，因为宏模式是与Rust代码结构而不是值匹配的。让我们逐步了解示例20-29中的模式片段的含义；有关完整的宏模式语法，请参阅"),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/macros-by-example.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Rust参考"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("首先，我们使用一组圆括号来包含整个模式。我们使用美元符号（"),a("code",[t._v("$")]),t._v("）在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号明确表示这是一个宏变量，而不是常规的Rust变量。接下来是一组圆括号，用于捕获在圆括号内匹配模式的值，以便在替换代码中使用。在"),a("code",[t._v("$()")]),t._v("内是"),a("code",[t._v("$x:expr")]),t._v("，它匹配任何Rust表达式并给表达式命名"),a("code",[t._v("$x")]),t._v("。")]),t._v(" "),a("p",[a("code",[t._v("$()")]),t._v("后面的逗号表示字面逗号分隔符字符必须出现在与"),a("code",[t._v("$()")]),t._v("内代码匹配的代码的每个实例之间。"),a("code",[t._v("*")]),t._v("指定模式匹配零个或多个前面的内容。")]),t._v(" "),a("p",[t._v("当我们用"),a("code",[t._v("vec![1, 2, 3];")]),t._v("调用这个宏时，"),a("code",[t._v("$x")]),t._v("模式与三个表达式"),a("code",[t._v("1")]),t._v("、"),a("code",[t._v("2")]),t._v("和"),a("code",[t._v("3")]),t._v("匹配三次。")]),t._v(" "),a("p",[t._v("现在让我们看看与此分支关联的代码主体中的模式："),a("code",[t._v("$()*")]),t._v("内的"),a("code",[t._v("temp_vec.push()")]),t._v("为模式中与"),a("code",[t._v("$()")]),t._v("匹配的每个部分生成，零次或多次，取决于模式匹配的次数。"),a("code",[t._v("$x")]),t._v("被替换为每个匹配的表达式。当我们用"),a("code",[t._v("vec![1, 2, 3];")]),t._v("调用这个宏时，替换此宏调用生成的代码将是以下内容：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" temp_vec "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    temp_vec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    temp_vec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    temp_vec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    temp_vec\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("我们已经定义了一个宏，它可以接受任意数量的任意类型的参数，并可以生成代码来创建包含指定元素的向量。")]),t._v(" "),a("p",[t._v("要了解更多关于如何编写宏的信息，请查阅在线文档或其他资源，例如Daniel Keep开始并由Lukas Wirth继续的"),a("a",{attrs:{href:"https://veykril.github.io/tlborm/",target:"_blank",rel:"noopener noreferrer"}},[t._v('"Rust宏小册子"'),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"用于从属性生成代码的过程宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用于从属性生成代码的过程宏"}},[t._v("#")]),t._v(" 用于从属性生成代码的过程宏")]),t._v(" "),a("p",[t._v("宏的第二种形式是过程宏，它更像函数（并且是一种过程类型）。过程宏接受一些代码作为输入，对该代码进行操作，并产生一些代码作为输出，而不是像声明式宏那样与模式匹配并用其他代码替换代码。三种过程宏是自定义"),a("code",[t._v("derive")]),t._v("、类似属性和类似函数，它们都以类似的方式工作。")]),t._v(" "),a("p",[t._v("创建过程宏时，定义必须驻留在具有特殊"),a("code",[t._v("crate")]),t._v("类型的自己的"),a("code",[t._v("crate")]),t._v("中。这是出于复杂的技术原因，我们希望在未来消除。在示例20-36中，我们展示了如何定义过程宏，其中"),a("code",[t._v("some_attribute")]),t._v("是使用特定宏变体的占位符。")]),t._v(" "),a("p",[t._v("文件名：src/lib.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" proc_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[some_attribute]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("some_name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-36：定义过程宏的示例")]),t._v(" "),a("p",[t._v("定义过程宏的函数接受"),a("code",[t._v("TokenStream")]),t._v("作为输入并产生"),a("code",[t._v("TokenStream")]),t._v("作为输出。"),a("code",[t._v("TokenStream")]),t._v("类型由Rust附带的"),a("code",[t._v("proc_macro")]),t._v(" crate定义，表示"),a("code",[t._v("token")]),t._v("序列。这是宏的核心：宏操作的源代码构成输入"),a("code",[t._v("TokenStream")]),t._v("，宏产生的代码是输出"),a("code",[t._v("TokenStream")]),t._v("。该函数还有一个附加的属性，指定我们正在创建哪种过程宏。我们可以在同一个"),a("code",[t._v("crate")]),t._v("中拥有多种过程宏。")]),t._v(" "),a("p",[t._v("让我们看看不同种类的过程宏。我们将从自定义"),a("code",[t._v("derive")]),t._v("宏开始，然后解释使其他形式不同的小差异。")]),t._v(" "),a("h3",{attrs:{id:"如何编写自定义derive宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何编写自定义derive宏"}},[t._v("#")]),t._v(" 如何编写自定义"),a("code",[t._v("derive")]),t._v("宏")]),t._v(" "),a("p",[t._v("让我们创建一个名为"),a("code",[t._v("hello_macro")]),t._v("的"),a("code",[t._v("crate")]),t._v("，它定义一个名为"),a("code",[t._v("HelloMacro")]),t._v("的"),a("code",[t._v("trait")]),t._v("，其中有一个名为"),a("code",[t._v("hello_macro")]),t._v("的关联函数。我们将提供一个过程宏，而不是让我们的用户为每种类型实现"),a("code",[t._v("HelloMacro")]),t._v(" trait，这样用户可以用"),a("code",[t._v("#[derive(HelloMacro)]")]),t._v("注解他们的类型以获得"),a("code",[t._v("hello_macro")]),t._v("函数的默认实现。默认实现将打印"),a("code",[t._v("Hello, Macro! My name is TypeName!")]),t._v("，其中"),a("code",[t._v("TypeName")]),t._v("是定义此"),a("code",[t._v("trait")]),t._v("的类型的名称。换句话说，我们将编写一个"),a("code",[t._v("crate")]),t._v("，使另一个程序员能够使用我们的"),a("code",[t._v("crate")]),t._v("编写如示例20-37的代码。")]),t._v(" "),a("p",[t._v("文件名：src/main.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("hello_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("hello_macro_derive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(HelloMacro)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-37：我们的"),a("code",[t._v("crate")]),t._v("用户在使用我们的过程宏时能够编写的代码")]),t._v(" "),a("p",[t._v("完成后，此代码将打印"),a("code",[t._v("Hello, Macro! My name is Pancakes!")]),t._v("。第一步是创建一个新的库"),a("code",[t._v("crate")]),t._v("，如下所示：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[t._v("$ cargo new hello_macro "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("lib\n")])])]),a("p",[t._v("接下来，我们将定义"),a("code",[t._v("HelloMacro")]),t._v(" trait及其关联函数：")]),t._v(" "),a("p",[t._v("文件名：src/lib.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("trait")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("HelloMacro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-38：我们将与"),a("code",[t._v("derive")]),t._v("宏一起使用的简单"),a("code",[t._v("trait")])]),t._v(" "),a("p",[t._v("我们有一个"),a("code",[t._v("trait")]),t._v("及其函数。此时，我们的"),a("code",[t._v("crate")]),t._v("用户可以实现"),a("code",[t._v("trait")]),t._v("以实现所需的功能，如示例20-39所示。")]),t._v(" "),a("p",[t._v("文件名：src/main.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("hello_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pancakes")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, Macro! My name is Pancakes!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-39：如果用户编写"),a("code",[t._v("HelloMacro")]),t._v(" trait的手动实现，它会是什么样子")]),t._v(" "),a("p",[t._v("但是，他们需要为每个要与"),a("code",[t._v("hello_macro")]),t._v("一起使用的类型编写实现块；我们希望让他们免于做这项工作。")]),t._v(" "),a("p",[t._v("此外，我们还不能为"),a("code",[t._v("hello_macro")]),t._v("函数提供默认实现来打印实现"),a("code",[t._v("trait")]),t._v("的类型的名称：Rust没有反射功能，因此它无法在运行时查找类型的名称。我们需要一个宏来在编译时生成代码。")]),t._v(" "),a("p",[t._v("下一步是定义过程宏。在撰写本文时，过程宏需要在自己的"),a("code",[t._v("crate")]),t._v("中。最终，这个限制可能会被取消。构造"),a("code",[t._v("crate")]),t._v("和宏"),a("code",[t._v("crate")]),t._v("的约定如下：对于名为"),a("code",[t._v("foo")]),t._v("的"),a("code",[t._v("crate")]),t._v("，自定义"),a("code",[t._v("derive")]),t._v("过程宏"),a("code",[t._v("crate")]),t._v("称为"),a("code",[t._v("foo_derive")]),t._v("。让我们在我们的"),a("code",[t._v("hello_macro")]),t._v("项目中启动一个名为"),a("code",[t._v("hello_macro_derive")]),t._v("的新"),a("code",[t._v("crate")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[t._v("$ cargo new hello_macro_derive "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("lib\n")])])]),a("p",[t._v("我们的两个"),a("code",[t._v("crate")]),t._v("紧密相关，因此我们在"),a("code",[t._v("hello_macro")]),t._v(" crate的目录中创建过程宏"),a("code",[t._v("crate")]),t._v("。如果我们更改"),a("code",[t._v("hello_macro")]),t._v("中的"),a("code",[t._v("trait")]),t._v("定义，我们也必须更改"),a("code",[t._v("hello_macro_derive")]),t._v("中过程宏的实现。这两个"),a("code",[t._v("crate")]),t._v("需要单独发布，使用这些"),a("code",[t._v("crate")]),t._v("的程序员需要将两者都添加为依赖项并将它们都引入作用域。我们可以让"),a("code",[t._v("hello_macro")]),t._v(" crate使用"),a("code",[t._v("hello_macro_derive")]),t._v("作为依赖项并重新导出过程宏代码。然而，我们构造项目的方式使程序员即使不想要"),a("code",[t._v("derive")]),t._v("功能也可以使用"),a("code",[t._v("hello_macro")]),t._v("。")]),t._v(" "),a("p",[t._v("我们需要将"),a("code",[t._v("hello_macro_derive")]),t._v(" crate声明为过程宏"),a("code",[t._v("crate")]),t._v("。我们还需要来自"),a("code",[t._v("syn")]),t._v("和"),a("code",[t._v("quote")]),t._v(" crate的功能，正如你稍后会看到的，所以我们需要将它们添加为依赖项。将以下内容添加到"),a("code",[t._v("hello_macro_derive")]),t._v("的Cargo.toml文件中：")]),t._v(" "),a("p",[t._v("文件名：hello_macro_derive/Cargo.toml：")]),t._v(" "),a("div",{staticClass:"language-toml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-toml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[t._v("lib")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("proc-macro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[t._v("dependencies")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("syn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2.0"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("quote")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1.0"')]),t._v("\n")])])]),a("p",[t._v("要开始定义过程宏，请将示例20-40中的代码放入"),a("code",[t._v("hello_macro_derive")]),t._v(" crate的src/lib.rs文件中。请注意，在我们添加"),a("code",[t._v("impl_hello_macro")]),t._v("函数的定义之前，此代码不会编译。")]),t._v(" "),a("p",[t._v("文件名：hello_macro_derive/src/lib.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("proc_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_macro_derive(HelloMacro)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro_derive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Construct a representation of Rust code as a syntax tree")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// that we can manipulate.")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" ast "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Build the trait implementation.")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("impl_hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-40：大多数过程宏"),a("code",[t._v("crate")]),t._v("为了处理Rust代码而需要的代码")]),t._v(" "),a("p",[t._v("注意我们已经将代码分成了"),a("code",[t._v("hello_macro_derive")]),t._v("函数（负责解析"),a("code",[t._v("TokenStream")]),t._v("）和"),a("code",[t._v("impl_hello_macro")]),t._v("函数（负责转换语法树）：这使得编写过程宏更方便。外部函数（在这种情况下是"),a("code",[t._v("hello_macro_derive")]),t._v("）中的代码对于你看到或创建的几乎每个过程宏"),a("code",[t._v("crate")]),t._v("都是相同的。你在内部函数（在这种情况下是"),a("code",[t._v("impl_hello_macro")]),t._v("）主体中指定的代码将根据你的过程宏的目的而有所不同。")]),t._v(" "),a("p",[t._v("我们已经引入了三个新的"),a("code",[t._v("crate")]),t._v("："),a("code",[t._v("proc_macro")]),t._v("、"),a("a",{attrs:{href:"https://crates.io/crates/syn",target:"_blank",rel:"noopener noreferrer"}},[t._v("syn"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"https://crates.io/crates/quote",target:"_blank",rel:"noopener noreferrer"}},[t._v("quote"),a("OutboundLink")],1),t._v("。"),a("code",[t._v("proc_macro")]),t._v(" crate随Rust一起提供，所以我们不需要将其添加到Cargo.toml中的依赖项中。"),a("code",[t._v("proc_macro")]),t._v(" crate是编译器的API，允许我们从我们的代码中读取和操作Rust代码。")]),t._v(" "),a("p",[a("code",[t._v("syn")]),t._v(" crate将Rust代码从字符串解析为我们可以执行操作的数据结构。"),a("code",[t._v("quote")]),t._v(" crate将"),a("code",[t._v("syn")]),t._v("数据结构转换回Rust代码。这些"),a("code",[t._v("crate")]),t._v("使解析我们可能想要处理的任何类型的Rust代码变得更加简单：为Rust代码编写完整的解析器不是一项简单的任务。")]),t._v(" "),a("p",[t._v("当库用户在类型上指定"),a("code",[t._v("#[derive(HelloMacro)]")]),t._v("时，将调用"),a("code",[t._v("hello_macro_derive")]),t._v("函数。这是可能的，因为我们在这里用"),a("code",[t._v("proc_macro_derive")]),t._v("注解了"),a("code",[t._v("hello_macro_derive")]),t._v("函数并指定了名称"),a("code",[t._v("HelloMacro")]),t._v("，它与我们的"),a("code",[t._v("trait")]),t._v("名称匹配；这是大多数过程宏遵循的约定。")]),t._v(" "),a("p",[a("code",[t._v("hello_macro_derive")]),t._v("函数首先将输入从"),a("code",[t._v("TokenStream")]),t._v("转换为我们可以解释和执行操作的数据结构。这就是"),a("code",[t._v("syn")]),t._v("发挥作用的地方。"),a("code",[t._v("syn")]),t._v("中的"),a("code",[t._v("parse")]),t._v("函数接受"),a("code",[t._v("TokenStream")]),t._v("并返回表示解析的Rust代码的"),a("code",[t._v("DeriveInput")]),t._v("结构。示例20-41显示了我们从解析"),a("code",[t._v("struct Pancakes;")]),t._v("字符串中获得的"),a("code",[t._v("DeriveInput")]),t._v("结构的相关部分。")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DeriveInput")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// --snip--")]),t._v("\n\n    ident"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ident")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        ident"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pancakes"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        span"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bytes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("95")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("103")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Struct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataStruct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            struct_token"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Struct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            fields"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Unit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            semi_token"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Semi")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-41：当解析示例20-37中具有宏属性的代码时，我们获得的"),a("code",[t._v("DeriveInput")]),t._v("实例")]),t._v(" "),a("p",[t._v("此结构的字段显示我们解析的Rust代码是一个单元结构，其"),a("code",[t._v("ident")]),t._v("（标识符，表示名称）为"),a("code",[t._v("Pancakes")]),t._v("。此结构上有更多字段用于描述各种Rust代码；查看"),a("a",{attrs:{href:"https://docs.rs/syn/2.0/syn/struct.DeriveInput.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("DeriveInput")]),t._v("的syn文档"),a("OutboundLink")],1),t._v("以获取更多信息。")]),t._v(" "),a("p",[t._v("很快我们将定义"),a("code",[t._v("impl_hello_macro")]),t._v("函数，这是我们构建要包含的新Rust代码的地方。但在我们这样做之前，请注意我们的"),a("code",[t._v("derive")]),t._v("宏的输出也是"),a("code",[t._v("TokenStream")]),t._v("。返回的"),a("code",[t._v("TokenStream")]),t._v("被添加到我们的"),a("code",[t._v("crate")]),t._v("用户编写的代码中，因此当他们编译他们的"),a("code",[t._v("crate")]),t._v("时，他们将获得我们在修改的"),a("code",[t._v("TokenStream")]),t._v("中提供的额外功能。")]),t._v(" "),a("p",[t._v("你可能已经注意到，如果对"),a("code",[t._v("syn::parse")]),t._v("函数的调用失败，我们调用"),a("code",[t._v("unwrap")]),t._v("来导致"),a("code",[t._v("hello_macro_derive")]),t._v("函数恐慌。我们的过程宏有必要在错误时恐慌，因为"),a("code",[t._v("proc_macro_derive")]),t._v("函数必须返回"),a("code",[t._v("TokenStream")]),t._v("而不是"),a("code",[t._v("Result")]),t._v("以符合过程宏API。我们通过使用"),a("code",[t._v("unwrap")]),t._v("简化了此示例；在生产代码中，你应该通过使用"),a("code",[t._v("panic!")]),t._v("或"),a("code",[t._v("expect")]),t._v("提供更具体的错误消息，说明出了什么问题。")]),t._v(" "),a("p",[t._v("现在我们有了将带注解的Rust代码从"),a("code",[t._v("TokenStream")]),t._v("转换为"),a("code",[t._v("DeriveInput")]),t._v("实例的代码，让我们生成在带注解类型上实现"),a("code",[t._v("HelloMacro")]),t._v(" trait的代码，如示例20-42所示。")]),t._v(" "),a("p",[t._v("文件名：hello_macro_derive/src/lib.rs：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("proc_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_macro_derive(HelloMacro)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro_derive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Construct a representation of Rust code as a syntax tree")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// that we can manipulate")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" ast "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Build the trait implementation")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("impl_hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("impl_hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DeriveInput")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ident"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" generated "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" #name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, Macro! My name is {}!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("stringify!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("#name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    generated"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("into")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("示例20-42：使用解析的Rust代码实现"),a("code",[t._v("HelloMacro")]),t._v(" trait")]),t._v(" "),a("p",[t._v("我们使用"),a("code",[t._v("ast.ident")]),t._v("获得包含带注解类型名称（标识符）的"),a("code",[t._v("Ident")]),t._v("结构实例。示例20-33中的结构显示，当我们在示例20-31中的代码上运行"),a("code",[t._v("impl_hello_macro")]),t._v("函数时，我们获得的"),a("code",[t._v("ident")]),t._v("将具有值为"),a("code",[t._v('"Pancakes"')]),t._v("的"),a("code",[t._v("ident")]),t._v("字段。因此，示例20-34中的"),a("code",[t._v("name")]),t._v("变量将包含一个"),a("code",[t._v("Ident")]),t._v("结构实例，当打印时，将是字符串"),a("code",[t._v('"Pancakes"')]),t._v("，即示例20-37中结构的名称。")]),t._v(" "),a("p",[a("code",[t._v("quote!")]),t._v("宏让我们定义我们想要返回的Rust代码。编译器期望的东西与"),a("code",[t._v("quote!")]),t._v("宏执行的直接结果不同，因此我们需要将其转换为"),a("code",[t._v("TokenStream")]),t._v("。我们通过调用"),a("code",[t._v("into")]),t._v("方法来做到这一点，该方法消耗这个中间表示并返回所需的"),a("code",[t._v("TokenStream")]),t._v("类型的值。")]),t._v(" "),a("p",[a("code",[t._v("quote!")]),t._v("宏还提供了一些非常酷的模板机制：我们可以输入"),a("code",[t._v("#name")]),t._v("，"),a("code",[t._v("quote!")]),t._v("会用变量"),a("code",[t._v("name")]),t._v("中的值替换它。你甚至可以进行一些类似于常规宏工作方式的重复。查看"),a("a",{attrs:{href:"https://docs.rs/quote",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("quote")]),t._v(" crate的文档"),a("OutboundLink")],1),t._v("以获得全面的介绍。")]),t._v(" "),a("p",[t._v("我们希望我们的过程宏为用户注解的类型生成我们的"),a("code",[t._v("HelloMacro")]),t._v(" trait的实现，我们可以通过使用"),a("code",[t._v("#name")]),t._v("获得该类型。"),a("code",[t._v("trait")]),t._v("实现有一个函数"),a("code",[t._v("hello_macro")]),t._v("，其主体包含我们想要提供的功能：打印"),a("code",[t._v("Hello, Macro! My name is")]),t._v("然后是带注解类型的名称。")]),t._v(" "),a("p",[t._v("这里使用的"),a("code",[t._v("stringify!")]),t._v("宏内置于Rust中。它接受一个Rust表达式，如"),a("code",[t._v("1 + 2")]),t._v("，并在编译时将表达式转换为字符串字面量，如"),a("code",[t._v('"1 + 2"')]),t._v("。这与"),a("code",[t._v("format!")]),t._v("或"),a("code",[t._v("println!")]),t._v("宏不同，后者计算表达式然后将结果转换为"),a("code",[t._v("String")]),t._v("。有可能"),a("code",[t._v("#name")]),t._v("输入可能是要按字面打印的表达式，所以我们使用"),a("code",[t._v("stringify!")]),t._v("。使用"),a("code",[t._v("stringify!")]),t._v("还通过在编译时将"),a("code",[t._v("#name")]),t._v("转换为字符串字面量来节省分配。")]),t._v(" "),a("p",[t._v("此时，"),a("code",[t._v("cargo build")]),t._v("应该在"),a("code",[t._v("hello_macro")]),t._v("和"),a("code",[t._v("hello_macro_derive")]),t._v("中都成功完成。让我们将这些"),a("code",[t._v("crate")]),t._v("连接到示例20-31中的代码，看看过程宏的运行情况！使用"),a("code",[t._v("cargo new pancakes")]),t._v("在你的项目目录中创建一个新的二进制项目。我们需要将"),a("code",[t._v("hello_macro")]),t._v("和"),a("code",[t._v("hello_macro_derive")]),t._v("作为依赖项添加到"),a("code",[t._v("pancakes")]),t._v(" crate的Cargo.toml中。如果你将你的"),a("code",[t._v("hello_macro")]),t._v("和"),a("code",[t._v("hello_macro_derive")]),t._v("版本发布到crates.io，它们将是常规依赖项；如果没有，你可以将它们指定为路径依赖项，如下所示：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[t._v("hello_macro "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" path "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"../hello_macro"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nhello_macro_derive "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" path "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"../hello_macro/hello_macro_derive"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("将示例20-37中的代码放入src/main.rs，然后运行"),a("code",[t._v("cargo run")]),t._v("：它应该打印"),a("code",[t._v("Hello, Macro! My name is Pancakes!")]),t._v("来自过程宏的"),a("code",[t._v("HelloMacro")]),t._v(" trait的实现被包含在内，而"),a("code",[t._v("pancakes")]),t._v(" crate不需要实现它；"),a("code",[t._v("#[derive(HelloMacro)]")]),t._v("添加了"),a("code",[t._v("trait")]),t._v("实现。")]),t._v(" "),a("p",[t._v("接下来，让我们探索其他类型的过程宏与自定义"),a("code",[t._v("derive")]),t._v("宏的不同之处。")])])}),[],!1,null,null,null);a.default=n.exports}}]);