(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{374:function(t,s,a){"use strict";a.r(s);var n=a(18),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"附录-a-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附录-a-关键字"}},[t._v("#")]),t._v(" 附录 A：关键字")]),t._v(" "),s("p",[t._v("以下列表包含 Rust 语言为当前或未来使用而保留的关键字。因此，它们不能用作标识符（除了我们将在“"),s("a",{attrs:{href:"#%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86%E7%AC%A6"}},[t._v("原始标识符")]),t._v("”部分讨论的原始标识符）。标识符是函数、变量、参数、结构字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期的名称。")]),t._v(" "),s("h3",{attrs:{id:"当前使用的关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当前使用的关键字"}},[t._v("#")]),t._v(" 当前使用的关键字")]),t._v(" "),s("p",[t._v("以下是当前使用的关键字列表及其功能描述。")]),t._v(" "),s("ul",[s("li",[t._v("as - 执行原始转换，消除包含项目的特定特征的歧义，或在 use 语句中重命名项目")]),t._v(" "),s("li",[t._v("async - 返回 Future 而不是阻止当前线程 (Future 表示一个可能还没有计算完成的值，或者是一个可以在将来某个时刻完成的操作。)")]),t._v(" "),s("li",[t._v("await - 暂停执行，直到 Future 的结果准备就绪")]),t._v(" "),s("li",[t._v("break - 立即退出循环")]),t._v(" "),s("li",[t._v("const - 定义常量项目或常量原始指针")]),t._v(" "),s("li",[t._v("continue - 继续进行下一次循环迭代")]),t._v(" "),s("li",[t._v("crate - 在模块路径中，引用 crate 根")]),t._v(" "),s("li",[t._v("dyn - 动态分派到特征对象")]),t._v(" "),s("li",[t._v("else - if 和 if let 控制流构造的回退")]),t._v(" "),s("li",[t._v("enum - 定义枚举")]),t._v(" "),s("li",[t._v("extern - 链接外部函数或变量")]),t._v(" "),s("li",[t._v("false - 布尔 false 文字")]),t._v(" "),s("li",[t._v("fn - 定义函数或函数指针类型")]),t._v(" "),s("li",[t._v("for - 循环遍历迭代器中的项目，实现特征或指定更高级别的生命周期")]),t._v(" "),s("li",[t._v("if - 根据条件表达式的结果进行分支")]),t._v(" "),s("li",[t._v("impl - 实现固有或特征功能")]),t._v(" "),s("li",[t._v("in - for 循环语法的一部分")]),t._v(" "),s("li",[t._v("let - 绑定变量")]),t._v(" "),s("li",[t._v("loop - 无条件循环")]),t._v(" "),s("li",[t._v("match - 将值与模式匹配")]),t._v(" "),s("li",[t._v("mod - 定义 module")]),t._v(" "),s("li",[t._v("move - 使闭包拥有其所有捕获的所有权")]),t._v(" "),s("li",[t._v("mut - 表示引用、原始指针或模式绑定中的可变性")]),t._v(" "),s("li",[t._v("pub - 表示结构字段、impl 块或模块中的公共可见性")]),t._v(" "),s("li",[t._v("ref - 通过引用绑定")]),t._v(" "),s("li",[t._v("return - 从函数返回")]),t._v(" "),s("li",[t._v("Self - 我们正在定义或实现的类型的类型别名")]),t._v(" "),s("li",[t._v("self - 方法主体或当前模块")]),t._v(" "),s("li",[t._v("static - 全局变量或持续整个程序执行的生命周期")]),t._v(" "),s("li",[t._v("struct - 定义结构")]),t._v(" "),s("li",[t._v("super - 当前模块的父模块")]),t._v(" "),s("li",[t._v("trait - 定义特征")]),t._v(" "),s("li",[t._v("true - 布尔真文字")]),t._v(" "),s("li",[t._v("type - 定义类型别名或关联类型")]),t._v(" "),s("li",[t._v("union - 定义"),s("a",{attrs:{href:"https://doc.rust-lang.org/reference/items/unions.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("联合"),s("OutboundLink")],1),t._v("；仅在联合声明中使用时才是关键字")]),t._v(" "),s("li",[t._v("unsafe - 表示不安全的代码、函数、特征或实现")]),t._v(" "),s("li",[t._v("use - 将符号带入范围")]),t._v(" "),s("li",[t._v("where - 表示约束类型的子句")]),t._v(" "),s("li",[t._v("while - 根据表达式的结果有条件地循环")])]),t._v(" "),s("h3",{attrs:{id:"为将来使用而保留的关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为将来使用而保留的关键字"}},[t._v("#")]),t._v(" 为将来使用而保留的关键字")]),t._v(" "),s("p",[t._v("以下关键字尚不具备任何功能，但由 Rust 保留以供将来使用。")]),t._v(" "),s("ul",[s("li",[t._v("abstract")]),t._v(" "),s("li",[t._v("become")]),t._v(" "),s("li",[t._v("box")]),t._v(" "),s("li",[t._v("do")]),t._v(" "),s("li",[t._v("final")]),t._v(" "),s("li",[t._v("macro")]),t._v(" "),s("li",[t._v("override")]),t._v(" "),s("li",[t._v("priv")]),t._v(" "),s("li",[t._v("try")]),t._v(" "),s("li",[t._v("typeof")]),t._v(" "),s("li",[t._v("unsized")]),t._v(" "),s("li",[t._v("virtual")]),t._v(" "),s("li",[t._v("yield")])]),t._v(" "),s("h3",{attrs:{id:"原始标识符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原始标识符"}},[t._v("#")]),t._v(" 原始标识符")]),t._v(" "),s("p",[t._v("原始标识符是一种语法，它允许你在通常不允许使用关键字的地方使用关键字。你可以通过在关键字前加上 "),s("code",[t._v("r#")]),t._v(" 来使用原始标识符。")]),t._v(" "),s("p",[t._v("例如，match 是一个关键字。如果你尝试编译以下使用 match 作为其名称的函数：")]),t._v(" "),s("p",[t._v("文件名：src/main.rs")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("match")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("needle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("str")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" haystack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("str")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    haystack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("contains")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("needle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("你将收到此错误：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("error: expected identifier, found keyword "),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),t._v("match"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n --"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" src/main.rs:4:4\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" fn match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("needle: "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("str, haystack: "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" -"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("    ^^^^^ expected identifier, found keyword\n")])])]),s("p",[t._v("错误表明你不能使用关键字 match 作为函数标识符。要将 match 用作函数名，你需要使用原始标识符语法，如下所示：")]),t._v(" "),s("p",[t._v("文件名：src/main.rs")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("r")]),t._v("#"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("needle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("str")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" haystack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("str")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    haystack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("contains")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("needle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("assert!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r#"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foobar"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("此代码将编译而不会出现任何错误。请注意函数定义中函数名称的 "),s("code",[t._v("r#")]),t._v(" 前缀以及在 main 中调用该函数的位置。")]),t._v(" "),s("p",[t._v("原始标识符允许你使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。这让我们可以更自由地选择标识符名称，并让我们能够与使用这些单词不是关键字的语言编写的程序集成。此外，原始标识符允许你使用与当前依赖项使用的 Rust 版本不同的版本编写的库。例如，try 在 2015 版中不是关键字，但在 2018 版中是关键字。如果你依赖使用 2015 版编写且具有 try 函数的库，则需要使用原始标识符语法（在本例中为 "),s("code",[t._v("r#try")]),t._v("）从 2018 版代码中调用该函数。有关版本的更多信息，请参阅"),s("RouterLink",{attrs:{to:"/doc/appendix/appendix-e.html"}},[t._v("附录 E")]),t._v("。")],1)])}),[],!1,null,null,null);s.default=e.exports}}]);