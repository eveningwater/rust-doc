(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{373:function(t,s,a){"use strict";a.r(s);var n=a(17),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),s("p",[t._v("Rust 中的每个值都属于特定的数据类型，这告诉 Rust 指定了哪种数据，以便它知道如何处理这些数据。我们将研究两种数据类型子集：标量和复合。")]),t._v(" "),s("p",[t._v("请记住，Rust 是一种静态类型语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值及其使用方式推断出我们想要使用的类型。在可能存在多种类型的情况下，例如当我们在第 2 章的“"),s("RouterLink",{attrs:{to:"/doc/guess-game.html#将猜测数字与秘密数字进行比较"}},[t._v("将猜测数字与秘密数字进行比较")]),t._v("”部分中使用 "),s("code",[t._v("parse")]),t._v(" 将字符串转换为数字类型时，我们必须添加类型注释，如下所示：")],1),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("如果我们不添加上述代码中所示的 "),s("code",[t._v(":u32")]),t._v(" 类型注释，Rust 将显示以下错误，这意味着编译器需要我们提供更多信息来知道我们要使用哪种类型：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo build\n   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Compiling")]),t._v(" no_type_annotations v0"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//projects/no_type_annotations)")]),t._v("\nerror"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("E0284")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("annotations")]),t._v(" needed\n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" src"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("         "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("must")]),t._v(" be known at this point\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" note"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" cannot satisfy `"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("_ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FromStr")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Err")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" _`\nhelp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" consider giving `guess` an explicit "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" guess"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Type */")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not a number!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("              "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("For")]),t._v(" more information about this error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" `rustc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("explain "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("E0284")]),t._v("`"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nerror"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" could not compile `no_type_annotations` "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bin "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"no_type_annotations"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" due to "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" previous error\n")])])]),s("p",[t._v("你将看到其他数据类型的不同类型注释。")]),t._v(" "),s("h3",{attrs:{id:"标量类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标量类型"}},[t._v("#")]),t._v(" 标量类型")]),t._v(" "),s("p",[t._v("标量类型表示单个值。Rust 有四种主要标量类型：整数、浮点数、布尔值和字符串。你可能在其他编程语言中见过这些类型。让我们来看看它们在 Rust 中的工作原理。")]),t._v(" "),s("h4",{attrs:{id:"整数类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数类型"}},[t._v("#")]),t._v(" 整数类型")]),t._v(" "),s("p",[t._v("整数是没有小数部分的数字。我们在第 2 章中使用了一种整数类型，即 u32 类型。此类型声明表示它所关联的值应为无符号整数（有符号整数类型以 i 而不是 u 开头），占用 32 位空间。表 3-1 显示了 Rust 中的内置整数类型。我们可以使用这些变量中的任何一种来声明整数值的类型。")]),t._v(" "),s("p",[t._v("表 3-1: Rust 中的整数类型")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("长度")]),t._v(" "),s("th",[t._v("有符号")]),t._v(" "),s("th",[t._v("无符号")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("8-bit")]),t._v(" "),s("td",[t._v("i8")]),t._v(" "),s("td",[t._v("u8")])]),t._v(" "),s("tr",[s("td",[t._v("16-bit")]),t._v(" "),s("td",[t._v("i16")]),t._v(" "),s("td",[t._v("u16")])]),t._v(" "),s("tr",[s("td",[t._v("32-bit")]),t._v(" "),s("td",[t._v("i32")]),t._v(" "),s("td",[t._v("u32")])]),t._v(" "),s("tr",[s("td",[t._v("64-bit")]),t._v(" "),s("td",[t._v("i64")]),t._v(" "),s("td",[t._v("u64")])]),t._v(" "),s("tr",[s("td",[t._v("128-bit")]),t._v(" "),s("td",[t._v("i128")]),t._v(" "),s("td",[t._v("u128")])]),t._v(" "),s("tr",[s("td",[t._v("arch(架构)")]),t._v(" "),s("td",[t._v("isize")]),t._v(" "),s("td",[t._v("usize")])])])]),t._v(" "),s("p",[t._v("每个变量可以是有符号的，也可以是无符号的，并且具有明确的大小。有符号和无符号指的是数字是否可能为负数，换句话说，数字是否需要带有符号（有符号）或者它是否永远都是正数，因此可以不用符号表示（无符号）。这就像在纸上写数字：当符号很重要时，数字会显示加号或减号；但是，当可以安全地假设数字为正数时，它不会显示符号。有符号数字使用"),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Two%27s_complement",target:"_blank",rel:"noopener noreferrer"}},[t._v("二进制补码表示法"),s("OutboundLink")],1),t._v("存储。")]),t._v(" "),s("p",[t._v("每个有符号变量可以存储从 -(2"),s("sup",[t._v("n - 1")]),t._v(") 到 2"),s("sup",[t._v("n - 1")]),t._v(" - 1（含）的数字，其中 n 是变量使用的位数。因此，i8 可以存储从 -(2"),s("sup",[t._v("7")]),t._v(") 到 2"),s("sup",[t._v("7")]),t._v(" - 1（等于 -128 到 127）的数字。无符号变量可以存储从 0 到 2"),s("sup",[t._v("n")]),t._v(" - 1 的数字，因此 u8 可以存储从 0 到 2"),s("sup",[t._v("8")]),t._v(" - 1（等于 0 到 255）的数字。")]),t._v(" "),s("p",[t._v("此外，isize 和 usize 类型取决于程序所运行的计算机的体系结构，在表 3-1 中表示为“arch(可以理解是架构的意思)一行”：如果使用 64 位体系结构，则为 64 位；如果使用 32 位体系结构，则为 32 位。")]),t._v(" "),s("p",[t._v("你可以采用表 3-2 中所示的任何一种形式来编写整数文字。请注意，可以为多种数字类型的数字文字允许使用类型后缀（例如"),s("code",[t._v("57u8")]),t._v("）来指定类型。数字文字还可以使用 "),s("code",[t._v("_")]),t._v(" 作为视觉分隔符，使数字更易于阅读，例如 "),s("code",[t._v("1_000")]),t._v("，其值与你指定 1000 时的值相同。")]),t._v(" "),s("p",[t._v("表 3-2: rust 中的整数文字")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("数值文字")]),t._v(" "),s("th",[t._v("示例")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Decimal")]),t._v(" "),s("td",[t._v("98_222")])]),t._v(" "),s("tr",[s("td",[t._v("Hex")]),t._v(" "),s("td",[t._v("0xff")])]),t._v(" "),s("tr",[s("td",[t._v("Octal")]),t._v(" "),s("td",[t._v("0o77")])]),t._v(" "),s("tr",[s("td",[t._v("Binary")]),t._v(" "),s("td",[t._v("0b1111_0000")])]),t._v(" "),s("tr",[s("td",[t._v("Byte (u8 only)")]),t._v(" "),s("td",[t._v("b'A'")])])])]),t._v(" "),s("p",[t._v("那么你如何知道要使用哪种类型的整数？如果你不确定，Rust 的默认值通常是不错的起点：整数类型默认为 i32。你使用 isize 或 usize 的主要情况是索引某种集合时。")]),t._v(" "),s("h5",{attrs:{id:"整数溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数溢出"}},[t._v("#")]),t._v(" 整数溢出")]),t._v(" "),s("p",[t._v("假设你有一个 u8 类型的变量，它可以保存 0 到 255 之间的值。如果你尝试将变量更改为该范围之外的值（例如 256），则会发生整数溢出，这可能导致两种行为之一。在调试模式下编译时，Rust 会检查整数溢出，如果发生此行为，则会导致程序在运行时崩溃。Rust 在程序因错误退出时使用术语“崩溃”；我们将在第 9 章的“无法恢复的崩溃错误！”部分更深入地讨论崩溃。")]),t._v(" "),s("p",[t._v("在使用 "),s("code",[t._v("--release")]),t._v(" 标志在发布模式下编译时，Rust 不会检查导致崩溃的整数溢出。相反，如果发生溢出，Rust 会执行二进制补码包装。简而言之，大于类型可以保存的最大值的值“包装”到类型可以保存的最小值。对于 u8，值 256 变为 0，值 257 变为 1，依此类推。程序不会崩溃，但变量的值可能不是你预期的值。依赖整数溢出的包装行为被视为错误。")]),t._v(" "),s("p",[t._v("要明确处理溢出的可能性，你可以使用标准库为原始数字类型提供的这些方法系列：")]),t._v(" "),s("ul",[s("li",[t._v("使用 "),s("code",[t._v("wrapping_*")]),t._v(" 方法（例如"),s("code",[t._v("wrapping_add")]),t._v("）在所有模式下包装。")]),t._v(" "),s("li",[t._v("如果使用 "),s("code",[t._v("checked_*")]),t._v(" 方法发生溢出，则返回 None 值。")]),t._v(" "),s("li",[t._v("返回 "),s("code",[t._v("overflowing_*")]),t._v(" 方法的值和一个布尔值，指示是否发生溢出。")]),t._v(" "),s("li",[t._v("使用 "),s("code",[t._v("saturating_*")]),t._v(" 方法在值的最小值或最大值处饱和。")])]),t._v(" "),s("h4",{attrs:{id:"浮点类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浮点类型"}},[t._v("#")]),t._v(" 浮点类型")])])}),[],!1,null,null,null);s.default=r.exports}}]);