(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{376:function(t,s,a){"use strict";a.r(s);var n=a(18),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"接受命令行参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接受命令行参数"}},[t._v("#")]),t._v(" 接受命令行参数")]),t._v(" "),s("p",[t._v("让我们像往常一样使用 "),s("code",[t._v("cargo new")]),t._v(" 创建一个新项目。我们将我们的项目命名为 minigrep，以区别于你系统上可能已经有的 grep 工具。")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo new minigrep\n     "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Created")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("binary")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("application"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" `minigrep` project\n$ cd minigrep\n")])])]),s("p",[t._v("第一个任务是让 "),s("code",[t._v("minigrep")]),t._v(" 接受它的两个命令行参数：文件路径和要搜索的字符串。也就是说，我们希望能够使用 "),s("code",[t._v("cargo run")]),t._v(" 运行我们的程序，两个连字符表示后面的参数是给我们的程序而不是给 "),s("code",[t._v("cargo")]),t._v(" 的，一个要搜索的字符串，以及要搜索的文件路径，如下所示：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo run "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" searchstring example"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n")])])]),s("p",[t._v("目前，由 "),s("code",[t._v("cargo new")]),t._v(" 生成的程序无法处理我们给它的参数。"),s("a",{attrs:{href:"https://crates.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("crates.io"),s("OutboundLink")],1),t._v(" 上的一些现有库可以帮助编写接受命令行参数的程序，但由于你刚刚学习这个概念，让我们自己实现这个功能。")]),t._v(" "),s("h3",{attrs:{id:"读取参数值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读取参数值"}},[t._v("#")]),t._v(" 读取参数值")]),t._v(" "),s("p",[t._v("为了使 "),s("code",[t._v("minigrep")]),t._v(" 能够读取我们传递给它的命令行参数值，我们需要 Rust 标准库中提供的 "),s("code",[t._v("std::env::args")]),t._v(" 函数。这个函数返回传递给 "),s("code",[t._v("minigrep")]),t._v(" 的命令行参数的迭代器。我们将在第 13 章全面介绍迭代器。现在，你只需要知道关于迭代器的两个细节：迭代器产生一系列的值，我们可以在迭代器上调用 "),s("code",[t._v("collect")]),t._v(" 方法将其转换为集合，例如包含迭代器产生的所有元素的向量。")]),t._v(" "),s("p",[t._v("示例 12-1 中的代码允许你的 "),s("code",[t._v("minigrep")]),t._v(" 程序读取传递给它的任何命令行参数，然后将值收集到一个向量中。")]),t._v(" "),s("p",[t._v("Filename: src/main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("collect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("dbg!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("示例 12-1：将命令行参数收集到向量中并打印它们")]),t._v(" "),s("p",[t._v("首先，我们通过 use 语句将 "),s("code",[t._v("std::env")]),t._v(" 模块引入作用域，以便我们可以使用它的 args 函数。注意，"),s("code",[t._v("std::env::args")]),t._v(" 函数嵌套在两个级别的模块中。正如我们在第 7 章中讨论的，在所需函数嵌套在多个模块中的情况下，我们选择将父模块引入作用域而不是函数本身。通过这样做，我们可以轻松使用 "),s("code",[t._v("std::env")]),t._v(" 中的其他函数。这也比添加 use "),s("code",[t._v("std::env::args")]),t._v(" 然后仅用 "),s("code",[t._v("args")]),t._v(" 调用函数更不容易混淆，因为 "),s("code",[t._v("args")]),t._v(" 可能很容易被误认为是当前模块中定义的函数。")]),t._v(" "),s("blockquote",[s("h3",{attrs:{id:"args-函数和无效的-unicode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args-函数和无效的-unicode"}},[t._v("#")]),t._v(" "),s("code",[t._v("args")]),t._v(" 函数和无效的 Unicode")]),t._v(" "),s("p",[t._v("注意，如果任何参数包含无效的 Unicode，"),s("code",[t._v("std::env::args")]),t._v(" 将会 panic。如果你的程序需要接受包含无效 Unicode 的参数，请使用 "),s("code",[t._v("std::env::args_os")]),t._v(" 代替。该函数返回一个产生 "),s("code",[t._v("OsString")]),t._v(" 值而不是 "),s("code",[t._v("String")]),t._v(" 值的迭代器。我们在这里选择使用 "),s("code",[t._v("std::env::args")]),t._v(" 是为了简单，因为 "),s("code",[t._v("OsString")]),t._v(" 值因平台而异，比 "),s("code",[t._v("String")]),t._v(" 值更复杂。")])]),t._v(" "),s("p",[t._v("在 "),s("code",[t._v("main")]),t._v(" 的第一行，我们调用 "),s("code",[t._v("env::args")]),t._v("，并立即使用 "),s("code",[t._v("collect")]),t._v(" 将迭代器转换为包含迭代器产生的所有值的向量。我们可以使用 "),s("code",[t._v("collect")]),t._v(" 函数创建多种类型的集合，所以我们明确注明 "),s("code",[t._v("args")]),t._v(" 的类型，指定我们想要一个字符串向量。虽然在 Rust 中你很少需要注明类型，但 "),s("code",[t._v("collect")]),t._v(" 是一个你经常需要注明的函数，因为 Rust 无法推断你想要的集合类型。")]),t._v(" "),s("p",[t._v("最后，我们使用调试宏打印向量。让我们先尝试不带参数运行代码，然后再带两个参数运行：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo run\n   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Compiling")]),t._v(" minigrep v0"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//projects/minigrep)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Finished")]),t._v(" `dev` profile "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("unoptimized "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" debuginfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("61s\n     "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Running")]),t._v(" `target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("debug"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("minigrep`\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("src"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"target/debug/minigrep"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo run "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" needle haystack\n   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Compiling")]),t._v(" minigrep v0"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//projects/minigrep)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Finished")]),t._v(" `dev` profile "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("unoptimized "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" debuginfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("57s\n     "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Running")]),t._v(" `target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("debug"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("minigrep needle haystack`\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("src"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"target/debug/minigrep"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"needle"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"haystack"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("注意，向量中的第一个值是 "),s("code",[t._v('"target/debug/minigrep"')]),t._v("，这是我们的二进制文件的名称。这与 C 中的参数列表行为相匹配，让程序使用它们在执行中被调用的名称。如果你想在消息中打印程序名称，或者根据用于调用程序的命令行别名来改变程序的行为，访问程序名称通常很方便。但对于本章的目的，我们将忽略它，只保存我们需要的两个参数。")]),t._v(" "),s("h3",{attrs:{id:"将参数值保存在变量中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将参数值保存在变量中"}},[t._v("#")]),t._v(" 将参数值保存在变量中")]),t._v(" "),s("p",[t._v("程序目前能够访问指定为命令行参数的值。现在我们需要将两个参数的值保存在变量中，以便我们可以在程序的其余部分使用这些值。我们在示例 12-2 中做到这一点。")]),t._v(" "),s("p",[t._v("Filename: src/main.rs:")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("collect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" query "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" file_path "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Searching for {query}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"In file {file_path}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("示例 12-2：创建变量来保存查询参数和文件路径参数")]),t._v(" "),s("p",[t._v("正如我们在打印向量时看到的，程序的名称占据了向量中 "),s("code",[t._v("args[0]")]),t._v(" 的第一个值，所以我们从索引 1 开始参数。"),s("code",[t._v("minigrep")]),t._v(" 接受的第一个参数是我们要搜索的字符串，所以我们将对第一个参数的引用放在变量 "),s("code",[t._v("query")]),t._v(" 中。第二个参数将是文件路径，所以我们将对第二个参数的引用放在变量 "),s("code",[t._v("file_path")]),t._v(" 中。")]),t._v(" "),s("p",[t._v("我们暂时打印这些变量的值，以证明代码按我们的意图工作。让我们再次运行这个程序，使用参数 "),s("code",[t._v("test")]),t._v(" 和 "),s("code",[t._v("sample.txt")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[t._v("$ cargo run "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" test sample"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Compiling")]),t._v(" minigrep v0"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//projects/minigrep)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Finished")]),t._v(" `dev` profile "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("unoptimized "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" debuginfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("0s\n     "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Running")]),t._v(" `target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("debug"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("minigrep test sample"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt`\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Searching")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" test\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("In")]),t._v(" file sample"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n")])])]),s("p",[t._v("太好了，程序正在工作！我们需要的参数的值被保存到了正确的变量中。稍后我们将添加一些错误处理来处理某些潜在的错误情况，例如当用户不提供任何参数时；现在，我们将忽略这种情况，转而添加文件读取功能。")])])}),[],!1,null,null,null);s.default=e.exports}}]);