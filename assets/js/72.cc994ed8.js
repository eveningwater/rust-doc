(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{425:function(t,s,v){"use strict";v.r(s);var _=v(18),l=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"无畏并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无畏并发"}},[t._v("#")]),t._v(" 无畏并发")]),t._v(" "),s("p",[t._v("安全高效地处理并发编程是Rust的另一个主要目标。并发编程（程序的不同部分独立执行）和并行编程（程序的不同部分同时执行）随着越来越多的计算机利用多处理器而变得越来越重要。历史上，在这些情况下编程一直很困难且容易出错。Rust希望改变这一点。")]),t._v(" "),s("p",[t._v('最初，Rust团队认为确保内存安全和防止并发问题是需要用不同方法解决的两个独立挑战。随着时间的推移，团队发现所有权和类型系统是帮助管理内存安全和并发问题的强大工具！通过利用所有权和类型检查，许多并发错误在Rust中是编译时错误而不是运行时错误。因此，与其让你花大量时间尝试重现运行时并发错误发生的确切情况，错误的代码将拒绝编译并提供解释问题的错误信息。这样，你可以在开发过程中修复代码，而不是在代码可能已经部署到生产环境后才发现问题。我们将Rust的这一方面称为"无畏并发"。无畏并发允许你编写没有微妙错误的代码，并且在重构时不会引入新的错误。')]),t._v(" "),s("blockquote",[s("p",[t._v('注意：为了简单起见，我们将许多问题称为并发问题，而不是更精确地说并发和/或并行问题。在本章中，每当我们使用"并发"一词时，请在心里替换为"并发和/或并行"。在下一章中，当区别更重要时，我们会更具体。')])]),t._v(" "),s("p",[t._v("许多语言对处理并发问题的解决方案持教条主义态度。例如，Erlang有优雅的消息传递并发功能，但在线程之间共享状态的方式却很晦涩。仅支持可能解决方案的一个子集对于高级语言来说是一种合理的策略，因为高级语言承诺通过放弃一些控制来获得抽象的好处。然而，低级语言应该在任何给定情况下提供最佳性能的解决方案，并且对硬件的抽象更少。因此，Rust提供了各种工具，可以以适合你的情况和需求的方式对问题进行建模。")]),t._v(" "),s("p",[t._v("以下是我们将在本章中涵盖的主题：")]),t._v(" "),s("ul",[s("li",[t._v("如何创建线程同时运行多段代码")]),t._v(" "),s("li",[t._v("消息传递并发，其中通道在线程之间发送消息")]),t._v(" "),s("li",[t._v("共享状态并发，其中多个线程可以访问某些数据")]),t._v(" "),s("li",[t._v("Sync和Send特性，它们将Rust的并发保证扩展到用户定义的类型以及标准库提供的类型")])])])}),[],!1,null,null,null);s.default=l.exports}}]);