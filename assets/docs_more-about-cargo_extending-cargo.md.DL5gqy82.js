import{_ as e,c as o,o as r,ag as t}from"./chunks/framework.CO45oJKY.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/more-about-cargo/extending-cargo.md","filePath":"docs/more-about-cargo/extending-cargo.md","lastUpdated":1754619623000}'),c={name:"docs/more-about-cargo/extending-cargo.md"};function n(s,a,d,i,g,l){return r(),o("div",null,a[0]||(a[0]=[t('<h2 id="使用自定义命令扩展-cargo" tabindex="-1">使用自定义命令扩展 Cargo <a class="header-anchor" href="#使用自定义命令扩展-cargo" aria-label="Permalink to &quot;使用自定义命令扩展 Cargo&quot;">​</a></h2><p>Cargo 的设计使你可以通过新的子命令扩展它，而无需修改它本身。如果你的 <code>$PATH</code> 中有一个名为 <code>cargo-something</code> 的二进制文件，你可以通过运行 <code>cargo something</code> 来使用它，就像它是 Cargo 的子命令一样。这样的自定义命令在你运行 <code>cargo --list</code> 时也会被列出。能够使用 <code>cargo install</code> 安装扩展，然后像使用内置 Cargo 工具一样运行它们，这是 Cargo 设计的一个超级便利的好处！</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>通过 Cargo 和 <a href="https://crates.io/" target="_blank" rel="noreferrer">crates.io</a> 共享代码是使 Rust 生态系统对许多不同任务有用的部分原因。Rust 的标准库小而稳定，但 crate 很容易共享、使用，并且可以按照与语言不同的时间表进行改进。不要羞于在 <a href="https://crates.io/" target="_blank" rel="noreferrer">crates.io</a> 上分享对你有用的代码；它很可能对其他人也有用！</p>',4)]))}const p=e(c,[["render",n]]);export{h as __pageData,p as default};
