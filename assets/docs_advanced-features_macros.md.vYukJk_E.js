import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.CO45oJKY.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/advanced-features/macros.md","filePath":"docs/advanced-features/macros.md","lastUpdated":1754619663000}'),l={name:"docs/advanced-features/macros.md"};function t(p,s,h,k,d,c){return e(),a("div",null,s[0]||(s[0]=[n(`<h2 id="宏" tabindex="-1">宏 <a class="header-anchor" href="#宏" aria-label="Permalink to &quot;宏&quot;">​</a></h2><p>我们在本文档网站中一直使用像<code>println!</code>这样的宏，但我们还没有完全探索宏是什么以及它是如何工作的。术语宏指的是Rust中的一系列功能：带有<code>macro_rules!</code>的声明式宏和三种过程宏：</p><ul><li>自定义<code>#[derive]</code>宏，指定与在<code>struct</code>和<code>enum</code>上使用的<code>derive</code>属性一起添加的代码</li><li>类似属性的宏，定义可在任何项上使用的自定义属性</li><li>类似函数的宏，看起来像函数调用，但对指定为其参数的<code>token</code>进行操作</li></ul><p>我们将依次讨论这些内容，但首先，让我们看看当我们已经有函数时，为什么我们还需要宏。</p><h2 id="宏和函数之间的区别" tabindex="-1">宏和函数之间的区别 <a class="header-anchor" href="#宏和函数之间的区别" aria-label="Permalink to &quot;宏和函数之间的区别&quot;">​</a></h2><p>从根本上说，宏是一种编写代码来编写其他代码的方式，这被称为元编程。在附录C中，我们讨论了<code>derive</code>属性，它为你生成各种<code>trait</code>的实现。我们在整本文档网站中也使用了<code>println!</code>和<code>vec!</code>宏。所有这些宏都会展开以生成比你手动编写的代码更多的代码。</p><p>元编程对于减少你必须编写和维护的代码数量很有用，这也是函数的作用之一。然而，宏有一些函数没有的额外功能。</p><p>函数签名必须声明函数具有的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用<code>println!(&quot;hello&quot;)</code>，或者用两个参数调用<code>println!(&quot;hello {}&quot;, name)</code>。此外，宏在编译器解释代码含义之前展开，因此宏可以，例如，在给定类型上实现<code>trait</code>。函数不能这样做，因为它在运行时被调用，而<code>trait</code>需要在编译时实现。</p><p>实现宏而不是函数的缺点是宏定义比函数定义更复杂，因为你在编写编写Rust代码的Rust代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。</p><p>宏和函数之间的另一个重要区别是，你必须在文件中调用宏之前定义宏或将其引入作用域，而不是函数，你可以在任何地方定义并在任何地方调用。</p><h2 id="使用macro-rules-进行通用元编程的声明式宏" tabindex="-1">使用<code>macro_rules!</code>进行通用元编程的声明式宏 <a class="header-anchor" href="#使用macro-rules-进行通用元编程的声明式宏" aria-label="Permalink to &quot;使用\`macro_rules!\`进行通用元编程的声明式宏&quot;">​</a></h2><p>Rust中最广泛使用的宏形式是声明式宏。这些有时也被称为&quot;示例宏&quot;、&quot;<code>macro_rules!</code>宏&quot;或简称为&quot;宏&quot;。声明式宏的核心允许你编写类似于Rust <code>match</code>表达式的东西。正如第6章中讨论的，<code>match</code>表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也将值与与特定代码关联的模式进行比较：在这种情况下，值是传递给宏的字面Rust源代码；模式与该源代码的结构进行比较；与每个模式关联的代码在匹配时替换传递给宏的代码。这一切都在编译期间发生。</p><p>要定义宏，你使用<code>macro_rules!</code>构造。让我们通过查看<code>vec!</code>宏是如何定义的来探索如何使用<code>macro_rules!</code>。第8章介绍了我们如何使用<code>vec!</code>宏创建具有特定值的新向量。例如，以下宏创建一个包含三个整数的新向量：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#![allow(unused)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">u32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们也可以使用<code>vec!</code>宏创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们无法使用函数做同样的事情，因为我们不会提前知道值的数量或类型。</p><p>示例20-35显示了<code>vec!</code>宏的稍微简化的定义。</p><p>文件名：src/lib.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[macro_export]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">macro_rules!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expr ),</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            let</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp_vec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            $</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                temp_vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            )</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            temp_vec</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-35：<code>vec!</code>宏定义的简化版本</p><blockquote><p>注意：标准库中<code>vec!</code>宏的实际定义包括预先分配正确内存量的代码。该代码是一个优化，我们在这里不包括它，以使示例更简单。</p></blockquote><p><code>#[macro_export]</code>注解表示每当定义宏的<code>crate</code>被引入作用域时，这个宏就应该可用。如果没有这个注解，宏就不能被引入作用域。</p><p>然后我们用<code>macro_rules!</code>和我们正在定义的宏的名称（不带感叹号）开始宏定义。在这种情况下，名称<code>vec</code>后跟花括号，表示宏定义的主体。</p><p><code>vec!</code>主体中的结构类似于<code>match</code>表达式的结构。这里我们有一个带有模式<code>( $( $x:expr ),* )</code>的分支，后跟<code>=&gt;</code>和与此模式关联的代码块。如果模式匹配，将发出关联的代码块。鉴于这是此宏中的唯一模式，只有一种有效的匹配方式；任何其他模式都会导致错误。更复杂的宏将有多个分支。</p><p>宏定义中的有效模式语法与第19章中涵盖的模式语法不同，因为宏模式是与Rust代码结构而不是值匹配的。让我们逐步了解示例20-29中的模式片段的含义；有关完整的宏模式语法，请参阅<a href="https://doc.rust-lang.org/reference/macros-by-example.html" target="_blank" rel="noreferrer">Rust参考</a>。</p><p>首先，我们使用一组圆括号来包含整个模式。我们使用美元符号（<code>$</code>）在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号明确表示这是一个宏变量，而不是常规的Rust变量。接下来是一组圆括号，用于捕获在圆括号内匹配模式的值，以便在替换代码中使用。在<code>$()</code>内是<code>$x:expr</code>，它匹配任何Rust表达式并给表达式命名<code>$x</code>。</p><p><code>$()</code>后面的逗号表示字面逗号分隔符字符必须出现在与<code>$()</code>内代码匹配的代码的每个实例之间。<code>*</code>指定模式匹配零个或多个前面的内容。</p><p>当我们用<code>vec![1, 2, 3];</code>调用这个宏时，<code>$x</code>模式与三个表达式<code>1</code>、<code>2</code>和<code>3</code>匹配三次。</p><p>现在让我们看看与此分支关联的代码主体中的模式：<code>$()*</code>内的<code>temp_vec.push()</code>为模式中与<code>$()</code>匹配的每个部分生成，零次或多次，取决于模式匹配的次数。<code>$x</code>被替换为每个匹配的表达式。当我们用<code>vec![1, 2, 3];</code>调用这个宏时，替换此宏调用生成的代码将是以下内容：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp_vec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    temp_vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    temp_vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    temp_vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    temp_vec</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们已经定义了一个宏，它可以接受任意数量的任意类型的参数，并可以生成代码来创建包含指定元素的向量。</p><p>要了解更多关于如何编写宏的信息，请查阅在线文档或其他资源，例如Daniel Keep开始并由Lukas Wirth继续的<a href="https://veykril.github.io/tlborm/" target="_blank" rel="noreferrer">&quot;Rust宏小册子&quot;</a>。</p><h2 id="用于从属性生成代码的过程宏" tabindex="-1">用于从属性生成代码的过程宏 <a class="header-anchor" href="#用于从属性生成代码的过程宏" aria-label="Permalink to &quot;用于从属性生成代码的过程宏&quot;">​</a></h2><p>宏的第二种形式是过程宏，它更像函数（并且是一种过程类型）。过程宏接受一些代码作为输入，对该代码进行操作，并产生一些代码作为输出，而不是像声明式宏那样与模式匹配并用其他代码替换代码。三种过程宏是自定义<code>derive</code>、类似属性和类似函数，它们都以类似的方式工作。</p><p>创建过程宏时，定义必须驻留在具有特殊<code>crate</code>类型的自己的<code>crate</code>中。这是出于复杂的技术原因，我们希望在未来消除。在示例20-36中，我们展示了如何定义过程宏，其中<code>some_attribute</code>是使用特定宏变体的占位符。</p><p>文件名：src/lib.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proc_macro;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[some_attribute]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-36：定义过程宏的示例</p><p>定义过程宏的函数接受<code>TokenStream</code>作为输入并产生<code>TokenStream</code>作为输出。<code>TokenStream</code>类型由Rust附带的<code>proc_macro</code> crate定义，表示<code>token</code>序列。这是宏的核心：宏操作的源代码构成输入<code>TokenStream</code>，宏产生的代码是输出<code>TokenStream</code>。该函数还有一个附加的属性，指定我们正在创建哪种过程宏。我们可以在同一个<code>crate</code>中拥有多种过程宏。</p><p>让我们看看不同种类的过程宏。我们将从自定义<code>derive</code>宏开始，然后解释使其他形式不同的小差异。</p><h2 id="如何编写自定义derive宏" tabindex="-1">如何编写自定义<code>derive</code>宏 <a class="header-anchor" href="#如何编写自定义derive宏" aria-label="Permalink to &quot;如何编写自定义\`derive\`宏&quot;">​</a></h2><p>让我们创建一个名为<code>hello_macro</code>的<code>crate</code>，它定义一个名为<code>HelloMacro</code>的<code>trait</code>，其中有一个名为<code>hello_macro</code>的关联函数。我们将提供一个过程宏，而不是让我们的用户为每种类型实现<code>HelloMacro</code> trait，这样用户可以用<code>#[derive(HelloMacro)]</code>注解他们的类型以获得<code>hello_macro</code>函数的默认实现。默认实现将打印<code>Hello, Macro! My name is TypeName!</code>，其中<code>TypeName</code>是定义此<code>trait</code>的类型的名称。换句话说，我们将编写一个<code>crate</code>，使另一个程序员能够使用我们的<code>crate</code>编写如示例20-37的代码。</p><p>文件名：src/main.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro_derive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[derive(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Pancakes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Pancakes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-37：我们的<code>crate</code>用户在使用我们的过程宏时能够编写的代码</p><p>完成后，此代码将打印<code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库<code>crate</code>，如下所示：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cargo new hello_macro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lib</span></span></code></pre></div><p>接下来，我们将定义<code>HelloMacro</code> trait及其关联函数：</p><p>文件名：src/lib.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> trait</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-38：我们将与<code>derive</code>宏一起使用的简单<code>trait</code></p><p>我们有一个<code>trait</code>及其函数。此时，我们的<code>crate</code>用户可以实现<code>trait</code>以实现所需的功能，如示例20-39所示。</p><p>文件名：src/main.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Pancakes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">impl</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloMacro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Pancakes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Macro! My name is Pancakes!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Pancakes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-39：如果用户编写<code>HelloMacro</code> trait的手动实现，它会是什么样子</p><p>但是，他们需要为每个要与<code>hello_macro</code>一起使用的类型编写实现块；我们希望让他们免于做这项工作。</p><p>此外，我们还不能为<code>hello_macro</code>函数提供默认实现来打印实现<code>trait</code>的类型的名称：Rust没有反射功能，因此它无法在运行时查找类型的名称。我们需要一个宏来在编译时生成代码。</p><p>下一步是定义过程宏。在撰写本文时，过程宏需要在自己的<code>crate</code>中。最终，这个限制可能会被取消。构造<code>crate</code>和宏<code>crate</code>的约定如下：对于名为<code>foo</code>的<code>crate</code>，自定义<code>derive</code>过程宏<code>crate</code>称为<code>foo_derive</code>。让我们在我们的<code>hello_macro</code>项目中启动一个名为<code>hello_macro_derive</code>的新<code>crate</code>：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cargo new hello_macro_derive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lib</span></span></code></pre></div><p>我们的两个<code>crate</code>紧密相关，因此我们在<code>hello_macro</code> crate的目录中创建过程宏<code>crate</code>。如果我们更改<code>hello_macro</code>中的<code>trait</code>定义，我们也必须更改<code>hello_macro_derive</code>中过程宏的实现。这两个<code>crate</code>需要单独发布，使用这些<code>crate</code>的程序员需要将两者都添加为依赖项并将它们都引入作用域。我们可以让<code>hello_macro</code> crate使用<code>hello_macro_derive</code>作为依赖项并重新导出过程宏代码。然而，我们构造项目的方式使程序员即使不想要<code>derive</code>功能也可以使用<code>hello_macro</code>。</p><p>我们需要将<code>hello_macro_derive</code> crate声明为过程宏<code>crate</code>。我们还需要来自<code>syn</code>和<code>quote</code> crate的功能，正如你稍后会看到的，所以我们需要将它们添加为依赖项。将以下内容添加到<code>hello_macro_derive</code>的Cargo.toml文件中：</p><p>文件名：hello_macro_derive/Cargo.toml：</p><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proc-macro = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">syn = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">quote = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0&quot;</span></span></code></pre></div><p>要开始定义过程宏，请将示例20-40中的代码放入<code>hello_macro_derive</code> crate的src/lib.rs文件中。请注意，在我们添加<code>impl_hello_macro</code>函数的定义之前，此代码不会编译。</p><p>文件名：hello_macro_derive/src/lib.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> proc_macro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> quote</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">quote;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[proc_macro_derive(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro_derive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Construct a representation of Rust code as a syntax tree</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // that we can manipulate.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> syn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unwrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Build the trait implementation.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    impl_hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ast)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-40：大多数过程宏<code>crate</code>为了处理Rust代码而需要的代码</p><p>注意我们已经将代码分成了<code>hello_macro_derive</code>函数（负责解析<code>TokenStream</code>）和<code>impl_hello_macro</code>函数（负责转换语法树）：这使得编写过程宏更方便。外部函数（在这种情况下是<code>hello_macro_derive</code>）中的代码对于你看到或创建的几乎每个过程宏<code>crate</code>都是相同的。你在内部函数（在这种情况下是<code>impl_hello_macro</code>）主体中指定的代码将根据你的过程宏的目的而有所不同。</p><p>我们已经引入了三个新的<code>crate</code>：<code>proc_macro</code>、<a href="https://crates.io/crates/syn" target="_blank" rel="noreferrer">syn</a>和<a href="https://crates.io/crates/quote" target="_blank" rel="noreferrer">quote</a>。<code>proc_macro</code> crate随Rust一起提供，所以我们不需要将其添加到Cargo.toml中的依赖项中。<code>proc_macro</code> crate是编译器的API，允许我们从我们的代码中读取和操作Rust代码。</p><p><code>syn</code> crate将Rust代码从字符串解析为我们可以执行操作的数据结构。<code>quote</code> crate将<code>syn</code>数据结构转换回Rust代码。这些<code>crate</code>使解析我们可能想要处理的任何类型的Rust代码变得更加简单：为Rust代码编写完整的解析器不是一项简单的任务。</p><p>当库用户在类型上指定<code>#[derive(HelloMacro)]</code>时，将调用<code>hello_macro_derive</code>函数。这是可能的，因为我们在这里用<code>proc_macro_derive</code>注解了<code>hello_macro_derive</code>函数并指定了名称<code>HelloMacro</code>，它与我们的<code>trait</code>名称匹配；这是大多数过程宏遵循的约定。</p><p><code>hello_macro_derive</code>函数首先将输入从<code>TokenStream</code>转换为我们可以解释和执行操作的数据结构。这就是<code>syn</code>发挥作用的地方。<code>syn</code>中的<code>parse</code>函数接受<code>TokenStream</code>并返回表示解析的Rust代码的<code>DeriveInput</code>结构。示例20-41显示了我们从解析<code>struct Pancakes;</code>字符串中获得的<code>DeriveInput</code>结构的相关部分。</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeriveInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // --snip--</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ident</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Ident</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ident</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Pancakes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        span</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> #</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">95</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">103</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        DataStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            struct_token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            fields</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            semi_token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                Semi</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-41：当解析示例20-37中具有宏属性的代码时，我们获得的<code>DeriveInput</code>实例</p><p>此结构的字段显示我们解析的Rust代码是一个单元结构，其<code>ident</code>（标识符，表示名称）为<code>Pancakes</code>。此结构上有更多字段用于描述各种Rust代码；查看<a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html" target="_blank" rel="noreferrer"><code>DeriveInput</code>的syn文档</a>以获取更多信息。</p><p>很快我们将定义<code>impl_hello_macro</code>函数，这是我们构建要包含的新Rust代码的地方。但在我们这样做之前，请注意我们的<code>derive</code>宏的输出也是<code>TokenStream</code>。返回的<code>TokenStream</code>被添加到我们的<code>crate</code>用户编写的代码中，因此当他们编译他们的<code>crate</code>时，他们将获得我们在修改的<code>TokenStream</code>中提供的额外功能。</p><p>你可能已经注意到，如果对<code>syn::parse</code>函数的调用失败，我们调用<code>unwrap</code>来导致<code>hello_macro_derive</code>函数恐慌。我们的过程宏有必要在错误时恐慌，因为<code>proc_macro_derive</code>函数必须返回<code>TokenStream</code>而不是<code>Result</code>以符合过程宏API。我们通过使用<code>unwrap</code>简化了此示例；在生产代码中，你应该通过使用<code>panic!</code>或<code>expect</code>提供更具体的错误消息，说明出了什么问题。</p><p>现在我们有了将带注解的Rust代码从<code>TokenStream</code>转换为<code>DeriveInput</code>实例的代码，让我们生成在带注解类型上实现<code>HelloMacro</code> trait的代码，如示例20-42所示。</p><p>文件名：hello_macro_derive/src/lib.rs：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> proc_macro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> quote</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">quote;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[proc_macro_derive(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HelloMacro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro_derive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Construct a representation of Rust code as a syntax tree</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // that we can manipulate</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> syn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unwrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Build the trait implementation</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    impl_hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ast)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> impl_hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">syn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DeriveInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TokenStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ident;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> generated </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> quote!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        impl</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloMacro</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> #name {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Macro! My name is {}!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(#name));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    generated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>示例20-42：使用解析的Rust代码实现<code>HelloMacro</code> trait</p><p>我们使用<code>ast.ident</code>获得包含带注解类型名称（标识符）的<code>Ident</code>结构实例。示例20-33中的结构显示，当我们在示例20-31中的代码上运行<code>impl_hello_macro</code>函数时，我们获得的<code>ident</code>将具有值为<code>&quot;Pancakes&quot;</code>的<code>ident</code>字段。因此，示例20-34中的<code>name</code>变量将包含一个<code>Ident</code>结构实例，当打印时，将是字符串<code>&quot;Pancakes&quot;</code>，即示例20-37中结构的名称。</p><p><code>quote!</code>宏让我们定义我们想要返回的Rust代码。编译器期望的东西与<code>quote!</code>宏执行的直接结果不同，因此我们需要将其转换为<code>TokenStream</code>。我们通过调用<code>into</code>方法来做到这一点，该方法消耗这个中间表示并返回所需的<code>TokenStream</code>类型的值。</p><p><code>quote!</code>宏还提供了一些非常酷的模板机制：我们可以输入<code>#name</code>，<code>quote!</code>会用变量<code>name</code>中的值替换它。你甚至可以进行一些类似于常规宏工作方式的重复。查看<a href="https://docs.rs/quote" target="_blank" rel="noreferrer"><code>quote</code> crate的文档</a>以获得全面的介绍。</p><p>我们希望我们的过程宏为用户注解的类型生成我们的<code>HelloMacro</code> trait的实现，我们可以通过使用<code>#name</code>获得该类型。<code>trait</code>实现有一个函数<code>hello_macro</code>，其主体包含我们想要提供的功能：打印<code>Hello, Macro! My name is</code>然后是带注解类型的名称。</p><p>这里使用的<code>stringify!</code>宏内置于Rust中。它接受一个Rust表达式，如<code>1 + 2</code>，并在编译时将表达式转换为字符串字面量，如<code>&quot;1 + 2&quot;</code>。这与<code>format!</code>或<code>println!</code>宏不同，后者计算表达式然后将结果转换为<code>String</code>。有可能<code>#name</code>输入可能是要按字面打印的表达式，所以我们使用<code>stringify!</code>。使用<code>stringify!</code>还通过在编译时将<code>#name</code>转换为字符串字面量来节省分配。</p><p>此时，<code>cargo build</code>应该在<code>hello_macro</code>和<code>hello_macro_derive</code>中都成功完成。让我们将这些<code>crate</code>连接到示例20-31中的代码，看看过程宏的运行情况！使用<code>cargo new pancakes</code>在你的项目目录中创建一个新的二进制项目。我们需要将<code>hello_macro</code>和<code>hello_macro_derive</code>作为依赖项添加到<code>pancakes</code> crate的Cargo.toml中。如果你将你的<code>hello_macro</code>和<code>hello_macro_derive</code>版本发布到crates.io，它们将是常规依赖项；如果没有，你可以将它们指定为路径依赖项，如下所示：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hello_macro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../hello_macro&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hello_macro_derive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../hello_macro/hello_macro_derive&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>将示例20-37中的代码放入src/main.rs，然后运行<code>cargo run</code>：它应该打印<code>Hello, Macro! My name is Pancakes!</code>来自过程宏的<code>HelloMacro</code> trait的实现被包含在内，而<code>pancakes</code> crate不需要实现它；<code>#[derive(HelloMacro)]</code>添加了<code>trait</code>实现。</p><p>接下来，让我们探索其他类型的过程宏与自定义<code>derive</code>宏的不同之处。</p>`,89)]))}const E=i(l,[["render",t]]);export{r as __pageData,E as default};
