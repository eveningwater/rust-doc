import{_ as o,c,o as t,ag as a}from"./chunks/framework.CO45oJKY.js";const d="/rust-doc/assets/trpl21-01.y76wKGry.png",T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/final-project/final-project.md","filePath":"docs/final-project/final-project.md","lastUpdated":1754567953000}'),r={name:"docs/final-project/final-project.md"};function i(l,e,p,s,n,_){return t(),c("div",null,e[0]||(e[0]=[a('<h2 id="最终项目-构建多线程web服务器" tabindex="-1">最终项目：构建多线程Web服务器 <a class="header-anchor" href="#最终项目-构建多线程web服务器" aria-label="Permalink to &quot;最终项目：构建多线程Web服务器&quot;">​</a></h2><p>这是一个漫长的旅程，但我们已经到达了本文档网站的结尾。在本章中，我们将一起构建最后一个项目，以演示我们在最后几章中涵盖的一些概念，以及回顾一些早期的课程。</p><p>对于我们的最终项目，我们将制作一个在Web浏览器中显示&quot;hello&quot;的Web服务器，如图21-1所示。</p><p><img src="'+d+'" alt=""></p><p>图21-1：我们的最终共享项目</p><p>以下是我们构建Web服务器的计划：</p><ol><li>了解一些关于<code>TCP</code>和<code>HTTP</code>的知识。</li><li>在<code>socket</code>上监听<code>TCP</code>连接。</li><li>解析少量<code>HTTP</code>请求。</li><li>创建适当的<code>HTTP</code>响应。</li><li>使用线程池改善我们服务器的吞吐量。</li></ol><p>在我们开始之前，我们应该提到两个细节。首先，我们将使用的方法不会是用Rust构建Web服务器的最佳方式。社区成员已经在<code>crates.io</code>上发布了许多生产就绪的<code>crate</code>，它们提供了比我们将构建的更完整的Web服务器和线程池实现。然而，我们在本章中的意图是帮助你学习，而不是走捷径。因为Rust是一种系统编程语言，我们可以选择我们想要使用的抽象级别，并且可以达到在其他语言中不可能或不实用的更低级别。</p><p>其次，我们在这里不会使用<code>async</code>和<code>await</code>。构建线程池本身就是一个足够大的挑战，而不用添加构建异步运行时！但是，我们将注意到<code>async</code>和<code>await</code>如何适用于我们在本章中将看到的一些相同问题。最终，正如我们在第17章中提到的，许多异步运行时使用线程池来管理它们的工作。</p><p>因此，我们将手动编写基本的<code>HTTP</code>服务器和线程池，以便你可以学习你将来可能使用的<code>crate</code>背后的一般思想和技术。</p>',10)]))}const m=o(r,[["render",i]]);export{T as __pageData,m as default};
