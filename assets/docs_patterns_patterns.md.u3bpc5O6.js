import{_ as t,c as a,o,ag as r}from"./chunks/framework.CO45oJKY.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/patterns/patterns.md","filePath":"docs/patterns/patterns.md","lastUpdated":1754642071000}'),s={name:"docs/patterns/patterns.md"};function c(d,e,l,p,n,i){return o(),a("div",null,e[0]||(e[0]=[r('<h2 id="模式与匹配" tabindex="-1">模式与匹配 <a class="header-anchor" href="#模式与匹配" aria-label="Permalink to &quot;模式与匹配&quot;">​</a></h2><p>模式是 Rust 中一种特殊的语法，用于匹配复杂和简单类型的结构。将模式与 <code>match</code> 表达式和其他构造结合使用，可以更好地控制程序的控制流。模式由以下一些组合构成：</p><ul><li>字面量</li><li>解构数组、枚举、结构体或元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul><p>一些模式示例包括 <code>x</code>、<code>(a, 3)</code> 和 <code>Some(Color::Red)</code>。在模式有效的上下文中，这些组件描述了数据的形状。然后，我们的程序将值与模式进行匹配，以确定它是否具有正确的数据形状来继续运行特定的代码。</p><p>要使用模式，我们将其与某个值进行比较。如果模式与值匹配，我们将在代码中使用该值的各个部分。回想第 6 章中使用模式的 <code>match</code> 表达式，例如硬币分类机的例子。如果值符合模式的形状，我们就可以使用命名部分。如果不符合，与模式关联的代码将不会运行。</p><p>本章是关于模式所有内容的参考。我们将介绍模式的有效使用位置、可驳斥模式和不可驳斥模式之间的区别，以及你可能会看到的不同类型的模式语法。在本章结束时，你将知道如何使用模式以清晰的方式表达许多概念。</p>',6)]))}const u=t(s,[["render",c]]);export{m as __pageData,u as default};
